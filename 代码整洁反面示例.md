# 重复代码（duplicated code）
重复代码一般是因为需求迭代比较快，开发小伙伴担心影响已有功能，就复制粘贴造成的。重复代码很难维护的，如果你要修改其中一段的代码逻辑，就需要修改多次，很可能出现遗漏的情况，随着项目中重复代码越来越多，项目变得越难维护。

# 长函数，长方法（long method）或者职责不清（违反单一职责原则）
长函数是指一个函数方法几百行甚至上千行，可读性大大降低，不便于理解， 有时MR合并请求流水线门禁会设置禁止超多一定行数的函数或方法过门禁，使用extract method工具，优化超大行的方法，抽取功能单一的代码片段，组成命名清晰的短函数。
**❌ 错误示例**：
```python
def process_order(order_data):
    # 1. 验证格式
    if not order_data.get("items"):
        raise ValueError("订单必须包含商品")
    
    # 2. 计算总价
    total = 0
    for item in order_data["items"]:
        total += item["price"] * item["quantity"]
    
    # 3. 应用折扣
    if order_data.get("discount_code"):
        total *= 0.9  # 10% 折扣
    
    # 4. 保存到数据库
    db.insert("orders", {
        "id": order_data["id"],
        "total": total,
        "status": "paid"
    })
    
    # 5. 发送邮件通知
    send_email(order_data["email"], f"订单已支付，金额：{total}")
    
    return {"order_id": order_data["id"], "total": total}
```

**正确拆分**：
```python
def validate_order(order_data):
    if not order_data.get("items"):
        raise ValueError("订单必须包含商品")

def calculate_total(order_data):
    total = sum(item["price"] * item["quantity"] for item in order_data["items"])
    if order_data.get("discount_code"):
        total *= 0.9
    return total

def save_order_to_db(order_id, total):
    db.insert("orders", {"id": order_id, "total": total, "status": "paid"})

def send_order_confirmation_email(email, total):
    send_email(email, f"订单已支付，金额：{total}")

def process_order(order_data):
    validate_order(order_data)
    total = calculate_total(order_data)
    save_order_to_db(order_data["id"], total)
    send_order_confirmation_email(order_data["email"], total)
    return {"order_id": order_data["id"], "total": total}
```

> 🔍 为什么重要？
> + 一个函数做太多事 → 难以测试、难维护、易出错。
> + 拆分后：可复用、易测试、易理解。

# 过大的类（large class）
一个类专注做一件事，类中的属性和方法为这一件事服务，不要在一个类中放入太多的功能，比如订单类中放入库存和积分还有支付相关的功能，这样可读性变差，而且违反了单一职责原则

# 过长参数列（long parameter）
函数或方法参数过多，可读性变差，且调用也容易出错，做新老接口兼容也比较麻烦。 将一组相关参数封装成结构体或者类，如将一组长参数封装成一个DTO类

# 依恋情结（feature envy）
某个方法或者函数为了计算某个值，从另一个类或者对象中调用了很多属于该对象的取值函数（一个函数使用了大量其他类的成员）。 这种情况下，可考虑有没必要将该函数或方法移动到它使用的类中。

# Switch语句、if 语句
如果代码中包含很多分支判断，这种情况下，考虑有没必要使用多态优化

# 过多的注释
避免用注释解释代码，避免过多的注释。 方法函数、变量命名要规范、浅显易懂，避免用注释解释代码。关键、复杂的业务，使用清晰、简明的注释。
+ 多余注释
+ 日志式注释
+ 用注释解释变量

```java
private Integer inputToken;  // 输入token长度
private Integer outputToken; // 输出token长度
```
上面这段代码注释就是用注释解释代码的典型反面示例、而且用注释解释变量。这种注释是多余的。 

# 命名不规范
方法函数、变量、类名、模块等需要简单明了，浅显易懂，避免靠自己主观联想瞎命名。 通常项目中还会出现错误的命名，常见于拼写错误。
```java
// 命名不规范示例
private Integer inputToken;  // 输入token长度
private Integer outputToken; // 输出token长度
```
上面这段代码命名不规范，inputToken看命名应该是一个字符串变量，但是变量类型却是整型，看注释命名应该改为 inputTokenLength

```python
# 错误的命名
from public.pubilc_model.trace_model import ProductVersion
```
上面的这段导入语句public拼写错误

# 混乱的代码层次调用
+ controller层直接调用dao层。
+ 下层模块调用上层业务逻辑
+ 异常捕获层次错误

**下层模块调用上层业务逻辑**  
```python
# user_service.py （高层业务逻辑）
class UserService:
    def create_user(self, user_data):
        # 1. 验证数据
        if not self.validate_user_data(user_data):
            raise ValueError("Invalid data")

        # 2. 保存用户
        user_id = self.save_user_to_db(user_data)

        # 3. 发送欢迎邮件（调用低层模块）
        EmailService.send_welcome_email(user_id)

        return {"user_id": user_id, "status": "created"}

    def validate_user_data(self, data):
        return data.get("name") and data.get("email")

    def save_user_to_db(self, data):
        # 模拟数据库保存
        return 123


# email_service.py （低层模块）
class EmailService:
    @staticmethod
    def send_welcome_email(user_id):
        # 问题：这里调用了高层的 UserService！
        user_service = UserService()
        user_data = user_service.get_user_by_id(user_id)
        print(f"Sending email to {user_data['email']}")

    def get_user_by_id(self, user_id):
        # 模拟数据库查询
        return {"name": "Alice", "email": "alice@example.com"}
```
> 低层模块 EmailService 调用了高层模块 UserService 的方法
> + EmailService 是“低层”：只负责发邮件，不关心用户是谁、从哪来
> + UserService 是“高层”：负责用户创建、验证、管理等核心业务

👉 本该是：高层调用低层（业务逻辑调用服务）
👉 但这里变成了：低层调用高层（发邮件的模块去查用户数据）

**异常捕获层次错误**  
```python
# database.py （底层模块）
def query_user(user_id):
    try:
        # 模拟数据库查询
        if user_id == 999:
            raise ConnectionError("DB connection failed")
        return {"id": user_id, "name": "Bob"}
    except ConnectionError as e:
        # ❌ 错误：在底层模块捕获异常并“处理”了
        print("Database layer handled the error.")
        return None


# user_service.py （高层业务逻辑）
def get_user_with_fallback(user_id):
    user = query_user(user_id)  # 从底层调用
    if user is None:
        # 问题：底层已经“处理”了异常，高层根本不知道发生了问题！
        return {"error": "User not found (fallback)"}
    return user
```

> 错误点 1：底层模块 query_user 捕获了异常并“处理”了
> 错误点 2：高层模块 get_user_with_fallback 无法感知底层异常，失去了错误处理的主动权
> 错误被“吞掉”了，高层无法知道是“数据库连接失败”还是“用户不存在”，失去了日志、监控、重试等能力。

**总结：代码层次调用混乱的“三大禁忌”**  
|禁忌|说明|正确做法|
|---|---|---|
|1. 下层调用上层|低层模块依赖高层业务逻辑|高层调用低层，低层不依赖高层|
|2. 异常在错误层级捕获|底层吞掉异常，高层无法感知|底层抛异常，高层捕获并处理|
|3. 职责不清，逻辑回流|业务逻辑跑到底层，或底层反向调用业务|严格分层：控制层-->业务层-->服务层-->数据层|

# 违反单一职责
一个函数干了 8 件事情，违反 单一职责原则，且调用链条太长，一旦出错，定位困难
```python
def handle_transaction(user_id, amount, currency):
    # 1. 验证用户
    if not validate_user(user_id):
        raise Exception("User invalid")

    # 2. 检查余额
    balance = get_balance(user_id)
    if balance < amount:
        raise Exception("Insufficient funds")

    # 3. 记录日志
    log_transaction(user_id, amount, currency)

    # 4. 调用第三方支付接口
    payment_result = call_payment_gateway(user_id, amount, currency)

    # 5. 更新用户余额
    update_balance(user_id, balance - amount)

    # 6. 发送通知
    send_notification(user_id, f"支付成功：{amount}{currency}")

    # 7. 触发风控检查
    if should_trigger_risk_check(user_id):
        trigger_risk_alert(user_id, amount)

    # 8. 最后返回结果
    return {"status": "success", "tx_id": generate_tx_id()}
```

# 过度嵌套的函数调用
五层嵌套 if，逻辑像“洋葱”一样层层剥开，函数名模糊，“send_welcome_email”是否成功？不知道，一旦出错，很难判断是哪个环节失败了。
```python
def process_user_data(user_id):
    if validate_user(user_id):
        if get_user_profile(user_id):
            if send_welcome_email(user_id):
                if log_action(user_id, "welcome_sent"):
                    return "Success"
                else:
                    return "Log failed"
            else:
                return "Email failed"
        else:
            return "Profile not found"
    else:
        return "Invalid user"
```
> 优化建议：把每一步拆成独立函数，加异常处理，提前返回失败

# 使用魔法数字
**❌ 错误示例**：
```python
if user.age > 18:
    print("成年人")
elif user.age > 12:
    print("青少年")
else:
    print("儿童")
```

**✅正确示例**：
```python
ADULT_AGE = 18
TEEN_AGE = 13

if user.age >= ADULT_AGE:
    print("成年人")
elif user.age >= TEEN_AGE:
    print("青少年")
else:
    print("儿童")
```
> 🔍 为什么重要？
> + 魔法数字难懂、易错
> + 修改时容易遗漏或者改错
> + 可读性差，团队协作困难

# 使用 == 比较浮点数

**❌ 错误示例**：
```python
if 0.1 + 0.2 == 0.3:
    print("相等")
else:
    print("不相等")
```
**✅ 正确示例**：
```python
from math import isclose

if isclose(0.1 + 0.2, 0.3, rel_tol=1e-9):
    print("相等")
else:
    print("不相等")
```

> 🔍 为什么重要？
> + 浮点数精度问题导致 0.1 + 0.2 != 0.3
> + 使用 isclose() 是标准做法，避免“假”错误判断

# 滥用全局变量或模块级变量
**❌ 错误示例**：
```python
# config.py
API_KEY = "abc123"
DEBUG_MODE = True

def get_user_data(user_id):
    if DEBUG_MODE:
        print(f"Fetching user {user_id}")
    return requests.get(f"https://api.example.com/users/{user_id}", headers={"Authorization": API_KEY})
```

**✅ 正确做法：通过依赖注入传递配置**：
```python
class UserService:
    def __init__(self, api_key: str, debug: bool = False):
        self.api_key = api_key
        self.debug = debug

    def get_user_data(self, user_id: int):
        if self.debug:
            print(f"Fetching user {user_id}")
        headers = {"Authorization": self.api_key}
        return requests.get(f"https://api.example.com/users/{user_id}", headers=headers)
```

> 🔍 为什么重要？
> + 全局变量是“隐藏依赖”，难以测试和模拟
> + 依赖注入让代码更灵活、可测试、可复用

# 忽略类型提示（不建议）

我们日常写的代码，大部分都不会在形参后标明参数类型，这种做法不建议

**❌ 错误示例**：
```python
def add_user(name, age, email):
    return {"name": name, "age": age, "email": email}
```

**✅ 正确示例**：
```python
from typing import Optional

def add_user(name: str, age: int, email: str) -> dict:
    """
    添加用户信息。
    """
    return {"name": name, "age": age, "email": email}
```

> 🔍 为什么重要？
> + 类型提示提升代码可读性和维护性。
> + IDE 能提供更精准的补全、跳转、错误提示。
> + 与 mypy 配合，提前发现类型错误。

# 使用list作为函数默认参数
**❌ 错误示例**：
```python
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("A"))  # ['A']
print(add_item("B"))  # ['A', 'B'] ❌
```

**✅ 正确示例**：
```python
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

? 🔍 为什么重要？
> + Python 的默认参数只在函数定义时计算一次
> + 如果使用可变对象（如 list、dict），会导致“状态共享”
> + 这是 Python 中最经典的陷阱之一！

# 忽略日志而使用print调试

**❌ 错误示例**：
```python
def process_data(data):
    print(f"Processing data: {data}")
    result = some_complex_logic(data)
    print(f"Result: {result}")
    return result
```
**✅ 正确示例**：
```python
import logging

logger = logging.getLogger(__name__)

def process_data(data):
    logger.info("开始处理数据", extra={"data": data})
    try:
        result = some_complex_logic(data)
        logger.info("数据处理完成", extra={"result": result})
        return result
    except Exception as e:
        logger.error("处理数据时出错", exc_info=True)
        raise
```

> 🔍 为什么重要？
> + print 是开发调试手段，上线后会污染日志。
> + logging 支持级别控制（DEBUG/INFO/WARNING/ERROR）、输出格式化、日志转发。
> + 生产环境必须用 logging，不能用 print

# 缺少函数/类的文档字符串（docstring）

**❌ 错误示例**：
```python
def calculate_discount(price, rate):
    return price * (1 - rate)
```

**✅ 正确示例**：
```python
def calculate_discount(price: float, rate: float) -> float:
    """
    计算商品折扣后的价格。

    Args:
        price (float): 原价，单位：元
        rate (float): 折扣率（0~1之间），如 0.1 表示 10% 折扣

    Returns:
        float: 折扣后价格

    Raises:
        ValueError: 当 price 或 rate 不合法时抛出
    """
    if price < 0 or not (0 <= rate <= 1):
        raise ValueError("price 必须为非负数，rate 必须在 0~1 之间")
    return price * (1 - rate)
```

> 🔍 为什么重要？
> + 没有文档，别人看不懂函数用途。
> + IDE 无法自动提示参数类型和含义。
> + 长期维护成本飙升。

# 不使用的代码不要注释掉，直接删除
如果考虑到后续可能会使用这段注释的代码
+ 如果这个文件不频繁改动，可以将文件复制备份，将源文件中注释删除，在使用时切到备份文件
+ 如果频繁改动，请及时删除注释掉的代码，如果后续要用回来，从提交记录中





