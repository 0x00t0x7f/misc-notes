## 架构演进
系统架构的演进大体上经历了这几个阶段
```mermaid
graph TD
    A(大型主机)
    B(主从架构)
    C(互联网)
    D(云、微服务、云原生)
    A-->B-->C-->D
```
### 第一代单体架构
所有功能打包在一个进程中，集成了系统的所有功能
单体架构后来又衍生出垂直单体， 当单节点的单体应用无法满足流量需求，企业将单体应用部署多份，分别放在不同服务器上就叫垂直单体架构
+ 紧耦合
+ 错综交互
+ 重复造轮子
+ 封闭

### 介入一、二代中间-界面和数据库分开的二层架构
+ 引入面向对象设计模式
+ 界面和数据库分离

### 第二代SOA架构
面向服务的架构，所有服务都注册在总线上，从总线上查找服务信息进行调用
+ 松耦合
+ 集中式架构
+ 停机手动扩容
+ 有状态

### 三层架构
常见的软件架构模型是三层架构，它将应用程序分为展示层、业务逻辑层和数据访问层， 这种架构模式在互联网发展早期业务规模较小时发挥了重要作用。属于典型的贫血模型。
```mermaid
graph TD
    A[表现层: UI]
    B[逻辑层: 业务逻辑]
    C[数据访问层]
    D[DB]
    A-->B-->C
    C-->B-->A
    C<-->D
```
其中在前后端分离的架构中，UI层又进一步分化为MVC的形式，MVC是协作关系而不是分层模式。

#### 三层架构优点
+ 分离解耦关注点： 将不用功能模块分开，每个模块专注于特定任务，一定程度上降低了代码复杂性
+ 可维护和可扩展性

#### 三层架构缺点
+ 业务逻辑分散：业务逻辑可能分散在不同的层，复杂业务场景难以理清，影响了代码的可读性和可维护性
+ 领域模型贫血： 业务逻辑和数据存储混在一起，领域业务扩展受限，难以表达复杂的业务场景规则

### 第三代 微服务容器化
更彻底的面向服务的架构，有完善的服务治理组件。每个功能形成独立服务，通过服务注册进行调用。
+ API契约解耦
+ 自动弹性扩缩容
+ 无状态服务
+ 升级扩容无感知
+ 资源利用不充分
+ 分布式事务、运维复杂度高

### 无服务架构
+ 资源按需使用付费
+ 更高效的资源利用
+ 100%平台托管
+ 自动伸缩
+ 不合适调用频繁的业务服务
+ 不适合复杂业务服务

### 单体到微服务的架构演进历程
在单体到微服务的架构演进历程中，有发展出了非常流行的分布式架构。
进入互联网时代后，用户从各个终端访问目标系统，单体架构无法支撑如此大流量和高并发的场景的背景下，分布式架构登上互联网历史舞台。
分布式架构是将单体服务架构中的各个功能模块拆分，部署到不同的服务器或者进程中进行独立管理和维护。

分布式架构的系统也会产生一些问题，比如分布式的数据一致性。
在分布式系统中，数据会存在多个副本，加上网络延迟等因素，数据同步会存在问题。  
**数据一致性问题**
+ 强一致性
+ 最终一致性（弱一致性）： 在可接受的时长内，数据副本保持一致。

**分布式架构 CAP定理**
+ 一致性（C）：所有节点访问时都是同一份最新的数据副本
+ 可用性（A）：非故障的节点在合理的时间内返回响应，丹不保证获取的数据是最新数据
+ 分区容错性（P）：遇到任何网络分区故障时仍然能够对外提供服务
有三种组合：CA、CP、AP

**分布式架构 BASE理论**
核心思想是：如果无法做到强一致性，每个应用可以根据自身业务特点，采用适当的方式达到最终一致性。BASE理论是CAP定理中的一致性和可用性权衡的结果。

**典型的分布式架构**
+ SOA架构
+ 微服务架构（MSA）

#### 分层架构
将软件模块按照水平切分的方式分成多层，一个系统由多个模块组成。同时，每层有自己独立的职责，多个层次协同提供完整的功能。
+ Dao层：操作数据库（PO+DAO）
+ Service层：处理业务逻辑（DTO+BO）
+ Controller层：接收请求/返回响应（DTO<-->VO）

#### 系统架构分层的目标
+ 高内聚
+ 低耦合
+ 复用
+ 扩展性

#### 典型的软件架构模式
+ 经典三层架构（见上三层架构介绍）
+ MVC架构（见下）
+ 六边形架构

#### MVC（模型、视图、控制器）
使用业务逻辑、数据、界面显示分离的方法组织代码。

##### 术语（类比现实场景）
+ DAO：仓库管理员（执行存取操作），封装数据库操作的接口，隔离业务层与持久层，提供CRUD方法。
+ PO：仓库中的原始货物（数据库记录）
+ DTO：物流运输中的标准包装（跨层传输数据对象），不包含业务逻辑
+ VO：商品货架上的陈列展示（前端展示），可包含数据展示方法和逻辑

##### DTO vs VO
DTO可能被多个VO复用， VO可能组合多个DTO

##### PO vs Entity
两者常等同，但 Entity在DDD中可能包含业务逻辑

##### 数据流转过程
```mermaid
flowchart LR
A[用户请求]
B[VO接收]
C[转为DTO]
D[Service处理]
E[DAO操作PO]
F[数据库读写]
G[反向转换回VO]

A-->B-->C-->D-->E-->F-->G-->A
```

随着互联网的发展和公司业务的不断扩展，业务规模越来越大，场景越来越复杂，service层也越来越庞大，服务与服务之间的相互调用越来越混乱，这种情况下项目的迭代也越来越慢，增加一个功能或者一个微小的改动牵一发而动全身，这为项目带来了极高的风险和不确定性。
一般情况下，解决这种问题可以通过引入领域驱动设计来解决。

### 领域驱动设计（DDD）
DDD是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，同时围绕业务概念构建领域模型。
DDD分层架构将数据、缓存等视为基础层，可以被所有层调用；抽离了领域层，负责核心业务逻辑处理，领域层调用外部依赖全部通过接口以保证领域层100%单测覆盖率；应用层聚合多个领域层的能力，只做功能的组合、转发、不复杂具体业务逻辑。
+ 领域的划分：DDD将service层按照业务场景划分为不同的领域，每个领域包含实体、值对象、聚合根等元素。
+ 领域的内聚：在领域内，业务尽量要内聚，避免领域之间的耦合。每个领域内可以根据需要进一步划分为更细粒度的子域，进一部提高内聚性。
```mermaid
graph TD
    A[接口层]
    B[应用层]
    C[领域层]
    D[基础层]
    A-->B-->C-->D
```
注：箭头指向被依赖方

+ 接口层：负责与其他服务，系统交互。处理传入数据的定义、校验、编解码、序列化操作。入参为DTO来协助数据转换，同时与领域对象、实体等解耦。如RESTful接口、MQS消费方
+ 应用层：负责完成完整的用例。协调多个领域服务、领域对象（实体、聚合根）实现服务编排和组合，该层通常不包含具体业务逻辑。该层设计：微服务编排和组合，分布式事务实现，消息驱动事件的驱动。
+ 领域层：实现企业核心业务逻辑，通过各种校验手段保证业务的正确性。领域层主要体现领域模型的业务能力，表达业务概念、业务状态和业务规则。领域层包含聚合根、实体、值对象、领域服务等领域模型中的领域对象。
+ 基础层：包含网关、缓存、数据库存储、消息中间件、监控、应用程序服务等通用的技术和基础服务以及其他服务的防腐。基础层以不同方式支持到其他三层，促进各层间通信。
  

#### DDD术语
##### 战略设计（高层结构）
也称为 战略建模；是指对业务进行高层次的抽象和归类
战略设计关注模型的分离，解决将大的模型如何划分为小模型以及相互之间如何关联。产出通常为限界上下文、模块、微服务划分等。  
**战略设计的几个关键术语**
+ 限界上下文（Bounded Context、BC）： 明确子域边界，外部通过接口/集成通信、每个微服务通常对应一个限界上下文，通常用于微服务的划分；同一个限界上下文内概念一致，跨限界上下文同一个概念可以不同含义。
+ 通用语言：业务人员和开发人员无歧义的统一语言，每个名词有清晰的概念和边界，同时是领域知识和抽象归纳的体现，形成了系统最重要的语义架构，是DDD中最核心的部分。
+ 领域/子域（Domain/Subdomain）：业务相关知识的集合
  - 核心域：核心业务，需重点建模
  - 通用域：业界已经有成熟方案的业务。同时被多个子域使用的通用功能子域或与行业无关的通用服务（如支付、认证），可采用第三方服务或者通用方案；通常偏技术，如消息通知、搜素、支付等。
  - 支撑域：辅助业务，且支撑域具有企业特性，但不具通用性，它是为了实现核心业务而不得不开发的业务所对应的相关知识的集合。
+ 上下文映射：描述各限界上下文之间的映射关系（如防腐层、共享内核、开放主机等等）

##### 战术设计（代码层落地）
是指对特定上下文下的模型进行详细设计
战术设计的对象包括聚合、实体和值对象。产出可以是用 UML表达的类图，需要细化到具体的属性，同时确保在代码级别可实现。
+ 实体： 在相同限界上下文中具有唯一标识（ID）的业务对象或领域模型、生命周期内标识不变，属性可变（如订单、用户），通过标识判断同一性。
+ 值对象：无唯一标识，属性决定其身份（如金额、数量、地址等），值对象不可变、可复用、可作为实体属性
+ 聚合：业务和领域模型中最小内聚单元，表现为一组生命周期强一致，修改规则强关联的实体和值对象的集合，表达统一的业务意义，对外屏蔽细节。
+ 聚合根：是聚合中最核心的实体，其他的实体和值对象都从属于这个实体。聚合根负责管理聚合内实体和值对象，同时是聚合对外的接口人。 聚合根是唯一入口（如订单聚合根管理订单行）
+ 领域服务：业务逻辑不属于某个实体/值对象时，可抽象为领域服务（如定价服务、风控服务等）。通常一个聚合有一个对应的领域服务，组织多个实体实现相对复杂的业务逻辑。
+ 领域事件：事件是系统状态发生的某种客观现象，领域事件是和领域有关的事件。通常由聚合内发起，聚合外监听处理。
+ 仓储：以持久化领域模型为职责的类，抽象持久化操作，负责聚合根的存取、屏蔽底层数据库细节。仓储的目的是屏蔽业务逻辑和持久化基础设施的差异，业务模型和存储解耦。
+ 工厂：负责复杂对象或聚合的创建过程

#### 代码组织
+ domain层：是DDD的核心，包含领域对象、值对象、聚合根。以及领域内的业务逻辑和规则。在领域内业务逻辑尽量内聚，而领域之间尽量松耦合。
+ 基础架构层：包括存储实现、队列实现、缓存实现等系统需要的基础设施能力，这一层主要为整个系统提供基础支撑
+ application层：用于组合领域内的服务，它不包含具体的业务逻辑，只是通过调用领域内的服务实现具体的功能
+ ui层：只是展示数据和接收用户输入，不包含业务逻辑，只是通过调用application层触发业务流程

#### 分层架构推荐示例
```mermaid
graph BT
A[基础设施层: <mark>仓储、外部服务、持久化</mark>]
B[领域层: <mark>实体、值对象、聚合、领域服务</mark>]
C[应用层: <mark>应用服务、编排、事务</mark>]
D[表现层: <mark>控制器、API、DTO</mark>]
A-->B-->C-->D
```
#### 限界上下文
业务模型的边界，每个上下文内模型语义一致，外部通过接口/集成通信。

通过对业务的划分，如订单系统，订单是一个子域，库存是另一个子域。 一个商品在不同的子域中表示的含义不同，在订单子域上下文中表示商品的单价、折扣等，在库存子域的上下文中商品表示 库存量、成本、存放位置。 多个子域之间的关联需要在应用层聚合，聚合的过程中就引出了技术方案， 比如订单——库存——支付需要采用同步方式；而这三个子域的通知调用可以采用异步方式，异步可能采用消息中间件等技术方案。

##### 划分示例（电商领域）
+ 订单上下文：订单生命周期管理、订单聚合、订单状态转移
+ 库存上下文： 库存管理、库存扣减、库存同步
+ 支付上下文：支付处理、退款、结算
+ 用户上下文： 用户信息、地址、配置
通常每个上下文可对应一个微服务，可独立部署和演进

##### BC划分规则
+ 先考虑团队规模：根据团队规模来确定需要划分多细粒度的BC，如果BC划分过小，而团队规模也小，可能对后期的开发、部署、上线、运维造成很大的负担
+ 考虑相关性：确定好粒度后，对语义相关性、功能相关性——业务方向、功能相关性——非业务方向进行划分

#### 事件驱动架构
+ 领域事件：业务状态的重要变化和转移； 如 订单已创建、订单已付款
+ 事件发布/订阅： 上下文之间通过事件异步解耦、集成。

##### 事件链示例（电商领域）
```mermaid
graph LR
A(下单)
B(库存服务订阅、进行库存预扣)
C(支付服务订阅、处理支付)
D(订单服务订阅、变更订单状态为已支付)

A-->|订单服务发布 OrderCreated事件|B-->|发布 InventoryReserved事件|C-->|发布OrderPaid事件|D
```
##### 领域事件技术实现
+ 消息总线（如 kafka、rabbitmq、rocketmq）负责事件分发
+ 事件消息体建议用领域语言和事件溯源ID

#### DDD与微服务/现代架构的关系
+ 限界上下文边界 == 微服务边界： 每个微服务聚焦单一业务子域，模型独立，松耦合。
+ 事件驱动： 领域事件实现服务间解耦，异步串联
+ CQRS/事件溯源： 复杂业务可用命令/查询分离、事件溯源提升可扩展性和审计能力
+ 高内聚低耦合： DDD天然支持微服务架构的高内聚、低耦合特点

#### DDD实践常见误区
+ 只做分层，不做领域建模，结果导致 贫血模型 的产生（只有属性没有行为）
+ 领域模型被 数据库、DTO、外部系统污染，丧失业务表达力
+ 过度追求 纯DDD，忽略了实际交付效率

#### DDD落地实践建议
+ 优先建模核心域，支撑/通用域 可用通用方案或外包
+ 与领域专家紧密合作，业务语言驱动建模
+ 仓库只暴露聚合根，持久化细节通过依赖倒置解耦
+ 领域事件驱动跨上下文集成，防腐层保护核心模型
+ 结合微服务、自动化测试、持续交付，提升团队协作与交付效率

## 架构设计
### 4A架构
4A架构是业务架构、应用架构、数据架构和技术架构的统称。
架构是为了构建一个满足业务需求、达成业务目标、运行稳定可靠、可扩展、可快速迭代功能的系统而进行的设计

### 4A架构之-业务架构
描述了企业如何通过价值流、工作流程、业务能力、组织架构等方面实现业务战略。
业务架构设计企业的治理架构、商业能力与价值流的正式蓝图。明确定义了企业的治理架构、业务能力、业务流程、业务数据。
业务架构定义企业做什么，业务流程定义企业怎么做。

#### 示例
+ 采购、供应商、财务业务架构
+ 工程采购业务流

### 4A架构之-应用架构
连接业务架构和技术架构的桥梁，将业务需求转化为技术可实现的功能
阐述再支撑业务运转的整个系统中，服务是如何切分的，一般每个服务都是由独立的开发小组进行迭代和维护的。简单分为“ 支撑应用、前台应用、后台应用。

#### 示例
+ 支撑应用： 用户权限、基础数据、解决方案、运营运维、数据底座
+ 后台应用：xx服务、订单服务..
+ 前台应用：租户、运营门户、供应商系统..

### 4A架构之-数据架构
数据资产管理蓝图，数据架构描述企业主要数据类型及来源，逻辑数据资产，物理数据资产，数据管理职责
指导如何分析数据需求、做好数据设计

**数据需求分析表示例**
|序号|数据实体|表名|数据量|数据实体说明|
|----|-------|----|------|-------------|
|1|采购订单行表|po_line_t|100w|采购订单行信息|

### 4A架构之-技术架构
技术架构阐述的技术选型、服务发布管理，涉及到的工具较广。
从开发流程看： 开发、构建、测试、部署、运行
从搭建顺序看：基础设施、基础服务、数据存储、服务实现、负载均衡/网关等

#### 搭建顺序示例
由下至上： 计算-->中间件-->公共服务-->应用服务-->编排中心-->门户

### 系统架构的4+1视图
4+1从不同关键角色的角度描述系统，并组成完整的系统架构描述。
参与和使用这些视图的角色有： 系统用户、开发者、系统工程师、项目经理、实施人员。
|视图|场景视图|逻辑视图|物理视图|处理视图|开发视图|
|:---:|:---:|:---:|:---:|:---:|:---:|
|阶段|分析阶段|分析阶段|设计阶段|设计阶段|设计阶段|
|视角|用户/使用者视角|软件系统分析、架构师视角|系统安装、调试工程师视角|系统处理分解|开发者、项目管理视角|
|关注点|用户可用性|软件功能、子系统、模块、组件的拆分|系统拓扑结构、系统安装、以及之间的交互|进程分解、并发、性能、吞吐量|软件开发|
|聚焦|功能特性的分析和分解|系统的功能分层|软件系统到物理的部署，服务器、数据库实例，网络VPN，网关等物理节点|处理逻辑分解|系统到子系统、模块、组件，代码仓的拆分|
|模型|用例视图，用户故事|组合结构图、类图|部署视图|时序图、协作图、状态图、活动图|组件视图、包视图|

+ 场景视图：是4+1视图的+1，核心，是其他视图的输入，其他视图围绕场景视图进行设计。
+ 逻辑视图：使用者的视角，从功能角度描述不同功能组件的层次关系
+ 处理视图：不同组件之间的行为关系，通常以时序图的方式表示
+ 开发视图：开发者视角下，从实现层面描述不同代码的包、类、库构成关系
+ 物理视图：系统所依托的物理视图，例如部署视图

### 系统架构的4+1视图——处理视图
处理视图有多个视角，常见的有：时序图、活动图、协作图（合作图）、状态图

### 系统架构的4+1视图——物理视图（部署视图）
物理视图用于描述系统软件到物理软硬件的映射关系，反映出系统的组件是如何部署到一组可计算机器节点上的。用于指导软件系统的部署实施过程。
物理环境可以是：服务器、PC机、移动终端等
软件环境可以是：容器、虚拟机、进程、线程。

#### 物理视图（部署视图）示例
+ 前台网关： 做用户校验、负责路由到中台网关
+ ALB：中台服务HTTP、HTTPS API负载均衡
+ WCM：静态资源服务器
+ 中台网关：复杂路由到相关中台服务
+ Eruka：中台服务的注册与发现
+ EKS：K8S集群负责容器化中台服务的部署，扩容和管理
+ 服务容器的规格：CPU，内存的上下限，弹性最小、最大POD个数
+ Redis缓存的规格：CPU，内存以及主备节点数
+ OpenGuass数据库规格：CPU，内存以及主备节点数

## 技术DFX设计
DFX是面向产品生命周期各环节的设计，其中X代表产品生命周期的某一个环节或特性，它是一种新的设计技术。在设计阶段尽可能早地考虑产品的性能、质量、可实现性、可测试性、产品服务和价格等因素，而对产品进行优化设计或再设计。

```mermaid
graph TD
    X(DFX)
    A(高性能)
    B(低成本)
    C(高可靠&高可用)
    D(架构归一)
    E(安全可靠)
    F(多环境自动化部署)
    G(运维运营)
    H(多租)

A---X
B---X
C---X
D---X
E---X
F---X
G---X
H---X
```
+ 高可靠&高可用：设计系统提供无故障服务，以避免因服务器宕机造成的服务不可用为目标做的架构设计；要达到高可用，系统要做好软硬件冗余，消除单点故障，同时做好故障转移，最短时间内发现故障，及时切换备用环境，
+ 高性能：针对应用的性能提升进行设计，包含后台服务的250ms（甚至更少 如200ms），页面3s性能保障；高并发，大单等极限场景的性能保障。
+ 安全可靠：如何防止攻击，防软件漏洞。设计安全编码，二三方软件安全可靠，敏感、隐私数据加密、保护、过滤、三面隔离等
+ 低成本：以节省和降低成本进行设计，在保证高可用的前提下，降低资源浪费，提高资源利用率，提高业务端到端的运行成本等。
+ 架构归一：架构统一管控设计，如 统一使用某种数据库，统一接入原生k8s，统一二三方件使用范围和版本管控，统一接入某种认证体系等。
+ 多环境自动化部署
+ 运营运维：应用监控、告警、运维运营设计合理的解决方案
+ 多租：针对不同模式的多租场景进行设计，涉及应用、数据、中间件、平台服务等放方面的多组方案，以及租户开租、管理等优化方案。

### 高可靠高可用之-数据库高可用架构
数据库架构主要分为：主备、主从、双活（双主）、存算分离

**主备**
+ 主备之间通过数据库日志同步数据
+ 备库只做数据备份，不具备实时切换能力
```mermaid
graph TD
    A(使用方)
    B(Master主)
    C(Slave备)

A-->B-->C
```

**主从**
+ 主从之间通过数据库日志实时同步
+ 主要一般承担写入，从库读取
+ 主从具备实时切换能力
+ 通过监控方式，当主库故障时，其中一个从库转为主库承担写入职责，同时作为新的数据源头，负责向其他从库同步数据
```mermaid
graph TD
    A(使用方)
    B(Master主)
    C(Slave从)
    D(Slave从)

A-->B
A --读取--> C & D
B -. 同步 .-> C & D
```
当主节点发生故障，主从切换， Master主被移出集群，其中一个Slave从转为主节点承担写入职责，并将结果同步给另一个Slave从节点。

**双主（双活）**
+ 数据库多个实例不分主从，都是主库，应用随机接入其中一个实例
+ 实例之间数据同步
+ 只要有一个实例存活即为可用，应用无感知
+ 主要难点在于数据同步一致性

```mermaid
flowchart TD
    A(使用方)
    B(Master主)
    C(Master主)

A-->B & C
B---同步---C
```

**存算分离**
+ 原有的数据库计算能力与存储分开，通过高速网络链接
+ 计算层具备计算弹性伸缩能力，大幅提高CPU利用率
+ 存储层只负责存储

## FAQ
### 一个BC代表一个微服务？
微服务一般是有高度相关功能的一个独立的开发部署单元，有自己的技术自治性、技术选型、弹性扩缩容，发布上下频率，可以各自维护，多个微服务可以组成一个完整的系统，多个业务之间各自管理
BC对应一个领域或一个模块或一个高内聚的业务，如果两个领域相关性很高，则一个微服务也可包含多个BC， 如果其中一个领域的访问量非常大， 则需要单独拆分为一个微服务中，弹性扩容以提高性能。
它俩之间没有必然的一一对应关系，限界上下文是领域模型的边界，用于明确业务领域的范围和规则，而微服务是架构上的决策，用于划分独立的服务单元。限界上下文可以作为设计微服务的指导原则，但具体如何对应需要根据实际的业务需求、系统复杂性和技术架构来决定，因此一个限界上下文不一定代表一个微服务。

### 聚合根与领域服务之间的关系？
聚合根与领域服务负责封装实现业务逻辑。领域服务负责对聚合根进行调度和封装，同时可以对外提供服务，对于不能直接通过聚合根完成的业务操作就需要通过领域服务。

### 什么是贫血模型？什么是充血模型？
贫血模型的实体有一堆属性和get、set方法，看不出具体的业务逻辑，要梳理这个实体关联什么业务，只能一层层的搜service，这就是贫血失忆症，不够面向对象。
而充血模型，除了get、set方法，还包含具体的业务方法，每个实体都是清晰的，这样的模型就叫充血模型，充血模型内存计算会多一些，内聚核心业务逻辑处理。这才是面向对象的本质。
+ 贫血模型：重 Service，轻 BO
+ 充血模型：轻 Service，重 Domain

```mermaid
graph LR

A[Service层]
B[贫血-传统]
C[充血-DDD]
B1[Service类: 业务逻辑]
B2[BO类: 只包含数据-贫血]
C1[Service类: 很单薄,事务,权限等]
C2[Domain类: 数据,业务逻辑-相当于贫血的BO类,但包含了业务逻辑]

A-->B
B-->B1
B-->B2
A-->C
C-->C1
C-->C2
```

### 领域模型应该是贫血还是充血？
看情况，推荐充血

### 应用层和领域层如何划分？
应用层更适合场景，领域层是基于业务规则和领域只是与场景和技术无关

### DDD的适用原则？
DDD适合大项目，逻辑复杂的场景，一般的小项目，MVC足够，在架构选型时，一定要先业务，后技术，先做语文题，后做数学题。聚合要先足够小，领域层先薄后厚，微服务先大后小。业务不稳定先不动，先做到职责单一化。

### DDD的价值？
+ 解决微服务拆分困境：使用ddd分析业务时，使用【聚合】把关联性强的业务概念划分到一个边界下，限定 聚合 和 聚合 之间只能通过 【聚合根】访问， 这是第一层边界。 在【聚合】基础上根据 业务相关性、业务变化频率、组织结构 等约束条件定义【限界上下文】，这是第二层边界。 有了这两层边界作为约束和限制，微服务的边界就比较清晰了，拆分微服务也就简单多了。
+ 应对系统复杂性：ddd的核心思想是避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，确定业务逻辑与技术实现的边界，从而隔离各自的复杂度，业务逻辑并不关心技术是如何实现的。不管采用何种技术实现，只要业务需求不变，业务规则也就不会变化。
