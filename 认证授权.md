# JWT

## 为什么要用JWT
想象一下你去餐厅吃饭：
+ 你走进餐厅，服务员问：“您有预约吗？”
+ 你说：“没有，但我带了身份证。”
+ 服务员核对身份证 → 确认你是真实顾客 → 允许你入座。

✅ 这个过程就是 “认证”（Authentication） —— 验证你是谁。

而 “授权”（Authorization） 是：你坐下来后，服务员问：“你想吃牛肉还是鱼？”
你说：“我想吃牛排。”
服务员说：“好的，这是您的牛排。”

👉 所以：
+ 认证：你是谁？（身份验证）
+ 授权：你能做什么？（权限控制）

## JWT是什么
✅ JWT（JSON Web Token）就是一个“数字身份证”，它把你的身份信息和权限信息，加密打包成一个字符串，你拿着它去访问系统，系统就能立刻认出你

## JWT的结构：长什么样
一个 JWT 字符串看起来像这样：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
它由 三部分组成，用 . 分隔：
```
Header.Payload.Signature
```
我们来拆开看，就像拆一个三明治一样：

**第一层： Header（头部）**  
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
+ alg：签名算法（比如 HS256，表示用 HmacSHA256 加密）
+ typ：类型，这里是JWT

👉 这部分告诉系统：“我是一个 JWT，用什么算法签的。”

**第二层：Payload（内容）———— 你的身份证信息（核心业务字段）**  
Payload 是 JWT 存储实际信息的核心部分，字段分为三类（均为可选，除exp外无强制要求）

（1）注册声明（Registered Claims）：官方推荐的标准字段

JWT 规范定义的通用字段，便于跨系统兼容，常用的有：
+ iss：Issuer，签发人 / 签发机构（如你的系统域名https://your-app.com）；
+ exp：Expiration Time，过期时间（Unix 时间戳，如1735689600，令牌在此时间后失效）；
+ iat：Issued At，签发时间（Unix 时间戳，记录令牌生成的时间）；
+ sub：Subject，主题（通常是用户唯一标识，如用户 ID user_888）；
+ aud：Audience，受众 / 接收方（指定令牌的使用方，如web_app、mobile_app）；
+ nbf：Not Before，生效时间（Unix 时间戳，令牌在此时间前不可用）；
+ jti：JWT ID，令牌唯一标识（防止重放攻击，可用于令牌黑名单）。

（2）公有声明（Public Claims）：自定义公共字段
开发者自定义，但需避免和注册声明冲突，通常带命名空间（如https://your-app.com/claims/role），示例：role（用户角色）、username（用户名）

（3）私有声明（Private Claims）：双方约定的字段
签发方和接收方私下约定的字段，仅双方识别，示例：user_id（用户 ID）、dept（部门）

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516239522
}
```
+ sub（subject）：用户唯一 ID（比如数据库主键）
+ name：用户名
+ iat（issued at）：签发时间（时间戳）

👉 你可以把这里想象成你的“身份证上的个人信息”。

> ⚠️ 注意：Payload 仅做 Base64 编码（可逆），所以绝对不能存储密码、密钥等敏感信息；即使 Payload 可以被解码（不是加密！），但不能随意篡改，否则签名会失效。

**第三层：Signature（签名）————你的防伪印章**  
Signature 不是 JSON 字段，而是通过「Header 指定的算法」，将「Base64 编码后的 Header + "." + Base64 编码后的 Payload」与密钥（秘钥）加密生成的字符串，用于验证令牌是否被篡改、是否由合法签发方生成。
这是最核心的一层！
它是由以下三部分拼起来，再用 密钥（secret key） 做签名：
```
HMACSHA256(
  base64UrlEncode(Header) + "." +
  base64UrlEncode(Payload),
  secret
)
```
👉 就像你身份证上的防伪水印，只有官方有“印章钥匙”，别人伪造不了。

## JWT工作流程（用生活场景类比）
我们用一个 “去银行取钱” 的故事来理解：

🎬 场景：小明去银行取钱
1. 小明走进银行，柜员问：“请出示您的身份证和银行卡。”
2. 小明拿出身份证 + 银行卡 → 柜员核对信息。
3. 核对无误后，柜员给小明一个 “身份令牌”（JWT），上面写着：
   - “持卡人：小明”
   - “卡号：6222 0000 1111 2222”
   - “有效期：2025-12-18 ~ 2025-12-19”
   - “签名：防伪章（只有银行知道）”
4. 小明拿着这个令牌，走向 ATM 机。
5. ATM 机扫了令牌 → 解码 Header + Payload → 然后用 银行的“钥匙” 验证 Signature 是否有效。
6. ✅ 验证通过 → ATM 机确认：“这是真实的小明，有权限取钱！”
7. 小明输入密码 → 成功取钱！

**关键点总结**  
|步骤|说明|
|---|---|
|1️⃣ 登录|用户提交账号密码 → 服务端验证 → 生成 JWT|
|2️⃣ 返回 JWT|服务端把 JWT 返回给前端（通常存进 localStorage）|
|3️⃣ 携带 JWT 请求|后续每次请求，前端在 Authorization 头中带上 JWT|
|4️⃣ 服务端验证|服务端解码 JWT → 验证签名 → 检查有效期 → 确认身份|
|5️⃣ 放行请求|验证通过 → 返回数据；失败 → 返回 401 错误|

## JWT的优点与缺点
|优点|缺点|
|---|---|
|✅无状态：服务端不存session，可水平扩展|❌无法主动注销（除非用黑名单机制）|
|✅自包含：用户信息和权限都在token里|❌一旦泄露，攻击者可长期冒用|
|✅跨域友好：适合前后端分离架构|❌体积比session大（不过可接受）|

## 总结
🎯 JWT 就像一张“电子身份证”，它把你的身份信息加密封装成一个字符串，你带着它去访问系统，系统用“钥匙”验证它是否真实有效
+ JWT不建议存储密码、银行卡号等敏感信息
+ 一定要用HTTPS传输JWT，防止被窃听
+ 设置合理的过期时间（如30min~2h）

## JWT FastApi示例模板

**✅ 进阶版核心功能（生产级）**  
|功能|说明|
|---|---|
|🔐 真实用户数据库（SQLAlchemy + PostgreSQL）|使用 ORM 持久化用户数据}|
|🔑 JWT 刷新令牌（Refresh Token）机制|实现“长期登录” + “安全登出”|
|🔴 Redis 黑名单（Token Revocation）|支持主动登出、强制失效 Token|
|📦 环境变量配置（.env）|敏感信息（如密钥、DB 连接）不硬编码|
|🛡️ Passlib 密码哈希 + 验证|安全存储与比对密码|
|🌐 HTTPS 支持（开发时可忽略）|生产环境必备|
|📊 Swagger UI + 自动文档|一键生成接口文档|

### 项目结构
```
jwt_fastapi_advanced/
├── .env                    ← 环境变量文件（不提交到 Git）
├── main.py                 ← 主应用
├── auth.py                 ← JWT 工具 + 刷新令牌 + 黑名单
├── models.py               ← SQLAlchemy 模型
├── database.py             ← 数据库连接配置
├── schemas.py              ← Pydantic 数据校验模型
├── requirements.txt        ← 依赖文件
└── README.md

# 更新后的项目结构
your-jwt-fastapi-project/
├── docker-compose.yml
├── .env
├── nginx/
│   ├── nginx.conf
│   └── conf.d/
│       └── fastapi.conf
├── app/
│   ├── main.py
│   ├── auth.py
│   ├── models.py
│   ├── schemas.py
│   ├── database.py
│   └── requirements.txt
├── .dockerignore
└── README.md
```

**.env环境变量**  
```
# ⚠️ 请替换为你的实际值
SECRET_KEY=your-32-char-secret-key-here-generated-by-openssl
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# 数据库连接（PostgreSQL 示例）
DATABASE_URL=postgresql+psycopg2://user:password@localhost:5432/jwt_app

# Redis 配置（用于黑名单）
REDIS_URL=redis://localhost:6379/0

# 更新后的环境变量
# 应用配置
APP_HOST=0.0.0.0
APP_PORT=8000

# JWT 配置
SECRET_KEY=your-32-char-secret-key-here-generated-by-openssl
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# 数据库配置
DATABASE_URL=postgresql+psycopg2://user:password@postgres:5432/jwt_app

# Redis 配置
REDIS_URL=redis://redis:6379/0

# Nginx 配置
DOMAIN=yourdomain.com
```
🔐 生成 SECRET_KEY 命令（推荐）：
```
openssl rand -hex 32
```

**database.py数据库连接**  
```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**models.py数据库模型（用户表）**  
```python
# models.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from database import Base
from datetime import datetime
from passlib.context import CryptContext

# 密码哈希上下文
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def get_password_hash(password: str) -> str:
        return pwd_context.hash(password)
```

**schemas.py Pydantic模型（请求/响应校验）**  
```python
# schemas.py
from pydantic import BaseModel
from typing import Optional

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class TokenPayload(BaseModel):
    sub: str
    exp: int
```

**auth.py JWT核心逻辑（含刷新令牌+黑名单）**  
```python
# auth.py
import jwt
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from typing import Optional
from models import User, UserCreate
from database import get_db
from sqlalchemy.orm import Session
from redis import Redis
from dotenv import load_dotenv
import os

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS"))

# Redis 客户端（用于黑名单）
redis_client = Redis.from_url(os.getenv("REDIS_URL"), decode_responses=True)

# 🔐 生成 JWT Token
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# 🔁 生成刷新 Token
def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# 🚫 将 Token 加入黑名单（登出时调用）
def invalidate_token(token: str, expires_in: int):
    redis_client.setex(f"revoked_token:{token}", expires_in, "1")

# 🛑 检查 Token 是否已被撤销
def is_token_revoked(token: str) -> bool:
    return redis_client.exists(f"revoked_token:{token}") == 1

# 🔍 验证用户登录
def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not User.verify_password(password, user.hashed_password):
        return None
    return user

# 🧑‍💼 获取当前用户（依赖项）
def get_current_user(token: str = Depends(get_token), db: Session = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except jwt.PyJWTError:
        raise credentials_exception

    # 检查是否被撤销
    if is_token_revoked(token):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has been revoked",
            headers={"WWW-Authenticate": "Bearer"},
        )

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise credentials_exception
    return user

# 📥 从 Authorization 头获取 Token
def get_token():
    pass
```

**main.py主应用文件**  
```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from auth import authenticate_user, create_access_token, create_refresh_token, get_current_user
from models import UserCreate, UserLogin, UserResponse, Token
from database import get_db

app = FastAPI(title="进阶版 JWT FastAPI 模板", version="1.0")

# 🌐 注册路由
@app.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register(user_data: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.username == user_data.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already registered")
    hashed_password = User.get_password_hash(user_data.password)
    new_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@app.post("/login", response_model=Token)
def login(login_data: UserLogin, db: Session = Depends(get_db)):
    user = authenticate_user(db, login_data.username, login_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/refresh", response_model=Token)
def refresh_token(refresh_token: str = Depends(get_token), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid refresh token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/logout")
def logout(token: str = Depends(get_token)):
    # 从 JWT 中提取子（username）或直接使用 token 本身
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    # 将 token 加入黑名单（过期时间 = refresh token 有效期）
    invalidate_token(token, REFRESH_TOKEN_EXPIRE_DAYS * 86400)
    return {"message": "Successfully logged out"}

# 🛡️ 保护接口
@app.get("/protected")
def protected_route(current_user: User = Depends(get_current_user)):
    return {
        "message": f"Hello, {current_user.username}! You are authenticated.",
        "user": current_user.dict()
    }

@app.get("/me")
def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```
### 项目部署
**nginx/nginx.conf**  
```
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # SSL 配置（Let's Encrypt）
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # 配置反向代理
    upstream fastapi_app {
        server app:8000;
    }

    server {
        listen 80;
        server_name ${DOMAIN};

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name ${DOMAIN};

        ssl_certificate_file /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
        ssl_certificate_key_file /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

        location / {
            proxy_pass http://fastapi_app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
        }

        location /docs {
            proxy_pass http://fastapi_app/docs;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /redoc {
            proxy_pass http://fastapi_app/redoc;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

**nginx/conf.d/fastapi.conf**  
```
# nginx/conf.d/fastapi.conf
server {
    listen 80;
    server_name ${DOMAIN};

    location / {
        return 301 https://$server_name$request_uri;
    }
}
```

**docker-compose.yml（核心配置）**  
```
version: '3.8'

services:
  # FastAPI 应用
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    container_name: fastapi_jwt_app
    ports:
      - "8000:8000"
    environment:
      - APP_HOST=0.0.0.0
      - APP_PORT=8000
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - REFRESH_TOKEN_EXPIRE_DAYS=${REFRESH_TOKEN_EXPIRE_DAYS}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    depends_on:
      - postgres
      - redis
    networks:
      - jwt-network

  # PostgreSQL 数据库
  postgres:
    image: postgres:15
    container_name: postgres_db
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=jwt_app
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./app/database_init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - jwt-network

  # Redis（用于 JWT 黑名单）
  redis:
    image: redis:7
    container_name: redis_cache
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - jwt-network

  # Nginx 反向代理 + HTTPS
  nginx:
    image: nginx:alpine
    container_name: nginx_proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./letsencrypt:/etc/letsencrypt
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - app
    networks:
      - jwt-network

# Docker 网络
networks:
  jwt-network:
    driver: bridge

# 数据卷
volumes:
  postgres_data:
  redis_data:
```

**app/Dockerfile**  
```
# app/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**启动与部署流程**  
```
# 1. 创建目录结构
mkdir -p your-jwt-fastapi-project/{app,nginx/conf.d,logs/nginx}

# 2. 将你的 `main.py`, `auth.py`, `models.py`, `schemas.py`, `database.py`, `requirements.txt` 放入 `app/`

# 3. 创建 `app/database_init.sql`（可选，用于初始化数据库）
# 示例：CREATE DATABASE jwt_app;

# 4. 修改 `.env` 文件中的 `SECRET_KEY` 和 `DOMAIN`（如 yourdomain.com）

# 5. 启动服务
# 进入项目根目录
cd your-jwt-fastapi-project

# 启动所有服务
docker-compose up -d
```

**HTTPS配置**  
🔐 建议使用 certbot 自动获取 HTTPS 证书。
```
# 在宿主机上运行 certbot（需开放 80 端口）
sudo docker run --rm -it \
  --name certbot \
  -v /etc/letsencrypt:/etc/letsencrypt \
  -v /var/lib/letsencrypt:/var/lib/letsencrypt \
  certbot/certbot certonly --manual --preferred-challenges=http -d yourdomain.com
```
> 📌 证书获取后，将 fullchain.pem 和 privkey.pem 复制到 nginx/letsencrypt/live/yourdomain.com/

**自动续期证书脚本**  
> 📝 保存为：/opt/letsencrypt/renew.sh
```
#!/bin/bash

# ========================================
# 🛠️ Let's Encrypt 自动续期脚本
# 📌 适用于 Docker Compose + Nginx 部署
# 📅 建议通过 cron 每月运行一次
# ========================================

# 🔧 配置变量
DOMAIN="yourdomain.com"             # 替换为你的域名
EMAIL="admin@yourdomain.com"      # Let's Encrypt 注册邮箱
LETS_ENCRYPT_DIR="/etc/letsencrypt"
RENEW_LOG="/var/log/letsencrypt/renew.log"

# 📁 确保日志目录存在
mkdir -p "$(dirname "$RENEW_LOG")"

# 📝 写入日志
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 开始续期 Let's Encrypt 证书 for $DOMAIN" >> "$RENEW_LOG"

# ✅ 检查是否已安装 certbot
if ! command -v certbot &> /dev/null; then
    echo "❌ certbot 未安装，请先安装 certbot。" >> "$RENEW_LOG"
    exit 1
fi

# 🔄 执行续期命令（使用手动模式，避免 HTTP 重定向冲突）
# 如果你之前用的是 `--manual` 模式，现在改用 `--webroot` 更安全
# 但如果你用的是 `--manual`，可以继续使用以下方式（需手动验证）

# ✅ 推荐方式：使用 webroot 模式（需 Nginx 保持 80 端口开放）
# 注意：必须确保 `/.well-known/acme-challenge/` 路由被 Nginx 正确代理到本地目录

# 📌 假设你已配置 Nginx 的 /etc/letsencrypt/webroot 目录
# 并且你的 Docker Compose 中 `nginx` 容器已映射了 `/.well-known` 路径

# 🔁 续期命令（推荐使用 webroot 模式）
if ! certbot renew --webroot --webroot-path=/var/lib/letsencrypt/.well-known/acme-challenge --email="$EMAIL" --agree-tos --no-self-upgrade --quiet; then
    echo "❌ Let's Encrypt 续期失败！" >> "$RENEW_LOG"
    exit 1
else
    echo "✅ Let's Encrypt 证书续期成功！" >> "$RENEW_LOG"
    
    # 🔄 重启 Nginx 以加载新证书
    echo "🔄 重启 Nginx 服务..." >> "$RENEW_LOG"
    if docker-compose exec nginx nginx -s reload; then
        echo "✅ Nginx 重启成功，证书已生效。" >> "$RENEW_LOG"
    else
        echo "❌ Nginx 重启失败，请检查日志。" >> "$RENEW_LOG"
        exit 1
    fi
fi

# ✅ 结束日志
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 续期流程结束。" >> "$RENEW_LOG"

exit 0
```

# OAuth2
不想把密码告诉别人，但又想让 A 应用访问 B 服务的数据” —— OAuth 2.0 就是解决这个问题的“安全授权协议”。

**成员**  
+ Client （第三方接入平台：请求者）
+ Resource Owner（资源拥有者：用户）
+ Resource Server（服务器资源：数据中心）
+ Authorization Server（认证服务器）

## OAuth2.0四种核心授权模式
|模式|中文名|通俗比喻|是否需要密码|
|---|---|---|---|
|1|授权码模式（Authorization Code）|微信登录网页版|❌ 不需要|
|2|隐式模式（又叫简化模式 Implicit）|前端单页应用（SPA）快速授权|❌ 不需要|
|3|密码模式（Resource Owner Password Credentials）|你直接把账号密码给一个可信应用、信任的客户端应用|✅ 需要|
|4|客户端凭证模式（Client Credentials）|服务之间通信（如后台系统调用 API、机机通信）|❌ 不需要|

## 四种模式对比总结
|模式|是否需要用户登录|是否需要后端|是否安全|适用场景|
|---|---|---|---|---|
|授权码模式|✅ 是|✅ 是|⭐⭐⭐⭐⭐|网站、App、任何有后端的场景|
|隐式模式（简化模式）|✅ 是|❌ 否|⭐⭐|纯前端 SPA（不推荐）|
|密码模式|✅ 是|✅ 是|⭐|极少数可信的内部系统（不推荐）|
|客户端凭证模式|❌ 否|✅ 是|⭐⭐⭐⭐|服务之间通信（推荐）|


## 总结建议
+ 绝大多数项目用“授权码模式” —— 安全、标准、推荐！
+ 纯前端 SPA 考虑用“授权码模式 + PKCE”（现代推荐方案，比隐式模式安全）
+ 不要用“隐式模式”和“密码模式”（除非你非常清楚风险）
+ 服务之间通信用“客户端凭证模式” —— 安全高效！

# FAQ
## SSO、JWT、OAuth2.0区别

**总结**：
+ SSO（单点登录） 是“目标”：一次登录，处处通行。
+ OAuth 2.0 是“协议/机制”：如何安全地授权第三方访问你的资源。
+ JWT（JSON Web Token） 是“工具/载体”：一种紧凑、自包含的令牌格式，常用于传输用户身份信息。

**三者关系图**：
```
                            +------------------+
                            |     SSO        |
                            |  (目标：一次登录) |
                            +------------------+
                                       │
                                       ▼
                            +------------------+
                            |   OAuth 2.0    |
                            | (协议：安全授权) |
                            +------------------+
                                       │
                                       ▼
                            +------------------+
                            |     JWT          |
                            | (载体：令牌格式) |
                            +------------------+
```

> ✅ 协同工作流程举例：
> 1. 你通过 SSO 登录了“科技园区”；
> 2. 系统用 OAuth 2.0 授权机制，让你授权“阿里云”访问你的某些数据；
> 3. 授权成功后，系统返回一个 JWT，里面包含了你的身份信息；
> 4. 你拿着这个 JWT 去访问阿里云服务，服务验证 JWT 有效后，就放行了。

**区别**：
|维度|SSO（单点登录）|OAuth 2.0（授权协议）|JWT（令牌格式）|
|---|---|---|---|
|本质|一种登录策略|一种授权协议|一种令牌格式|
|解决的问题|“一次登录，处处通行”|“如何让第三方安全访问我的资源”|“如何在不依赖数据库的情况下传输用户信息”|
|是否需要用户参与|✅ 是（登录）|✅ 是（授权）|❌ 否（自包含）|
|是否安全|依赖底层实现|安全协议，有多种模式|安全（需签名），但不能撤销|
|常见使用场景|企业内网、门户系统、大型平台|微信登录、QQ登录、第三方授权|API 认证、前后端分离、微服务通信|
|能否独立使用|❌ 不能，需配合协议/工具|❌ 不能，需配合令牌格式|❌ 不能，需配合协议使用|

**选型指南**：
|你正在做什么？|推荐组合|
|---|---|
|做一个企业内网门户，用户登录一次就能进所有系统|✅ SSO + OAuth 2.0 + JWT|
|做一个 App，用户用微信登录|✅ SSO（微信登录） + OAuth 2.0（授权流程） + JWT（返回 token）|
|做一个微服务架构，服务间通信|✅ OAuth 2.0（客户端凭证模式） + JWT（传递身份信息）|
|只想做一个简单的 API 验证|✅ JWT（但需配合签名机制）|
