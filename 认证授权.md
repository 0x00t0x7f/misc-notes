# JWT

## ä¸ºä»€ä¹ˆè¦ç”¨JWT
æƒ³è±¡ä¸€ä¸‹ä½ å»é¤å…åƒé¥­ï¼š
+ ä½ èµ°è¿›é¤å…ï¼ŒæœåŠ¡å‘˜é—®ï¼šâ€œæ‚¨æœ‰é¢„çº¦å—ï¼Ÿâ€
+ ä½ è¯´ï¼šâ€œæ²¡æœ‰ï¼Œä½†æˆ‘å¸¦äº†èº«ä»½è¯ã€‚â€
+ æœåŠ¡å‘˜æ ¸å¯¹èº«ä»½è¯ â†’ ç¡®è®¤ä½ æ˜¯çœŸå®é¡¾å®¢ â†’ å…è®¸ä½ å…¥åº§ã€‚

âœ… è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯ â€œè®¤è¯â€ï¼ˆAuthenticationï¼‰ â€”â€” éªŒè¯ä½ æ˜¯è°ã€‚

è€Œ â€œæˆæƒâ€ï¼ˆAuthorizationï¼‰ æ˜¯ï¼šä½ åä¸‹æ¥åï¼ŒæœåŠ¡å‘˜é—®ï¼šâ€œä½ æƒ³åƒç‰›è‚‰è¿˜æ˜¯é±¼ï¼Ÿâ€
ä½ è¯´ï¼šâ€œæˆ‘æƒ³åƒç‰›æ’ã€‚â€
æœåŠ¡å‘˜è¯´ï¼šâ€œå¥½çš„ï¼Œè¿™æ˜¯æ‚¨çš„ç‰›æ’ã€‚â€

ğŸ‘‰ æ‰€ä»¥ï¼š
+ è®¤è¯ï¼šä½ æ˜¯è°ï¼Ÿï¼ˆèº«ä»½éªŒè¯ï¼‰
+ æˆæƒï¼šä½ èƒ½åšä»€ä¹ˆï¼Ÿï¼ˆæƒé™æ§åˆ¶ï¼‰

## JWTæ˜¯ä»€ä¹ˆ
âœ… JWTï¼ˆJSON Web Tokenï¼‰å°±æ˜¯ä¸€ä¸ªâ€œæ•°å­—èº«ä»½è¯â€ï¼Œå®ƒæŠŠä½ çš„èº«ä»½ä¿¡æ¯å’Œæƒé™ä¿¡æ¯ï¼ŒåŠ å¯†æ‰“åŒ…æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ æ‹¿ç€å®ƒå»è®¿é—®ç³»ç»Ÿï¼Œç³»ç»Ÿå°±èƒ½ç«‹åˆ»è®¤å‡ºä½ 

## JWTçš„ç»“æ„ï¼šé•¿ä»€ä¹ˆæ ·
ä¸€ä¸ª JWT å­—ç¬¦ä¸²çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
å®ƒç”± ä¸‰éƒ¨åˆ†ç»„æˆï¼Œç”¨ . åˆ†éš”ï¼š
```
Header.Payload.Signature
```
æˆ‘ä»¬æ¥æ‹†å¼€çœ‹ï¼Œå°±åƒæ‹†ä¸€ä¸ªä¸‰æ˜æ²»ä¸€æ ·ï¼š

**ç¬¬ä¸€å±‚ï¼š Headerï¼ˆå¤´éƒ¨ï¼‰**  
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
+ algï¼šç­¾åç®—æ³•ï¼ˆæ¯”å¦‚ HS256ï¼Œè¡¨ç¤ºç”¨ HmacSHA256 åŠ å¯†ï¼‰
+ typï¼šç±»å‹ï¼Œè¿™é‡Œæ˜¯JWT

ğŸ‘‰ è¿™éƒ¨åˆ†å‘Šè¯‰ç³»ç»Ÿï¼šâ€œæˆ‘æ˜¯ä¸€ä¸ª JWTï¼Œç”¨ä»€ä¹ˆç®—æ³•ç­¾çš„ã€‚â€

**ç¬¬äºŒå±‚ï¼šPayloadï¼ˆå†…å®¹ï¼‰â€”â€”â€”â€” ä½ çš„èº«ä»½è¯ä¿¡æ¯**  
```
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```
+ subï¼ˆsubjectï¼‰ï¼šç”¨æˆ·å”¯ä¸€ IDï¼ˆæ¯”å¦‚æ•°æ®åº“ä¸»é”®ï¼‰
+ nameï¼šç”¨æˆ·å
+ iatï¼ˆissued atï¼‰ï¼šç­¾å‘æ—¶é—´ï¼ˆæ—¶é—´æˆ³ï¼‰

ğŸ‘‰ ä½ å¯ä»¥æŠŠè¿™é‡Œæƒ³è±¡æˆä½ çš„â€œèº«ä»½è¯ä¸Šçš„ä¸ªäººä¿¡æ¯â€ã€‚

> âš ï¸ æ³¨æ„ï¼šè™½ç„¶ Payload å¯ä»¥è¢«è§£ç ï¼ˆä¸æ˜¯åŠ å¯†ï¼ï¼‰ï¼Œä½†ä¸èƒ½éšæ„ç¯¡æ”¹ï¼Œå¦åˆ™ç­¾åä¼šå¤±æ•ˆã€‚

**ç¬¬ä¸‰å±‚ï¼šSignatureï¼ˆç­¾åï¼‰â€”â€”â€”â€”ä½ çš„é˜²ä¼ªå°ç« **  
è¿™æ˜¯æœ€æ ¸å¿ƒçš„ä¸€å±‚ï¼
å®ƒæ˜¯ç”±ä»¥ä¸‹ä¸‰éƒ¨åˆ†æ‹¼èµ·æ¥ï¼Œå†ç”¨ å¯†é’¥ï¼ˆsecret keyï¼‰ åšç­¾åï¼š
```
HMACSHA256(
  base64UrlEncode(Header) + "." +
  base64UrlEncode(Payload),
  secret
)
```
ğŸ‘‰ å°±åƒä½ èº«ä»½è¯ä¸Šçš„é˜²ä¼ªæ°´å°ï¼Œåªæœ‰å®˜æ–¹æœ‰â€œå°ç« é’¥åŒ™â€ï¼Œåˆ«äººä¼ªé€ ä¸äº†ã€‚

## JWTå·¥ä½œæµç¨‹ï¼ˆç”¨ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼‰
æˆ‘ä»¬ç”¨ä¸€ä¸ª â€œå»é“¶è¡Œå–é’±â€ çš„æ•…äº‹æ¥ç†è§£ï¼š

ğŸ¬ åœºæ™¯ï¼šå°æ˜å»é“¶è¡Œå–é’±
1. å°æ˜èµ°è¿›é“¶è¡Œï¼ŒæŸœå‘˜é—®ï¼šâ€œè¯·å‡ºç¤ºæ‚¨çš„èº«ä»½è¯å’Œé“¶è¡Œå¡ã€‚â€
2. å°æ˜æ‹¿å‡ºèº«ä»½è¯ + é“¶è¡Œå¡ â†’ æŸœå‘˜æ ¸å¯¹ä¿¡æ¯ã€‚
3. æ ¸å¯¹æ— è¯¯åï¼ŒæŸœå‘˜ç»™å°æ˜ä¸€ä¸ª â€œèº«ä»½ä»¤ç‰Œâ€ï¼ˆJWTï¼‰ï¼Œä¸Šé¢å†™ç€ï¼š
   - â€œæŒå¡äººï¼šå°æ˜â€
   - â€œå¡å·ï¼š6222 0000 1111 2222â€
   - â€œæœ‰æ•ˆæœŸï¼š2025-12-18 ~ 2025-12-19â€
   - â€œç­¾åï¼šé˜²ä¼ªç« ï¼ˆåªæœ‰é“¶è¡ŒçŸ¥é“ï¼‰â€
4. å°æ˜æ‹¿ç€è¿™ä¸ªä»¤ç‰Œï¼Œèµ°å‘ ATM æœºã€‚
5. ATM æœºæ‰«äº†ä»¤ç‰Œ â†’ è§£ç  Header + Payload â†’ ç„¶åç”¨ é“¶è¡Œçš„â€œé’¥åŒ™â€ éªŒè¯ Signature æ˜¯å¦æœ‰æ•ˆã€‚
6. âœ… éªŒè¯é€šè¿‡ â†’ ATM æœºç¡®è®¤ï¼šâ€œè¿™æ˜¯çœŸå®çš„å°æ˜ï¼Œæœ‰æƒé™å–é’±ï¼â€
7. å°æ˜è¾“å…¥å¯†ç  â†’ æˆåŠŸå–é’±ï¼

**å…³é”®ç‚¹æ€»ç»“**  
|æ­¥éª¤|è¯´æ˜|
|---|---|
|1ï¸âƒ£ ç™»å½•|ç”¨æˆ·æäº¤è´¦å·å¯†ç  â†’ æœåŠ¡ç«¯éªŒè¯ â†’ ç”Ÿæˆ JWT|
|2ï¸âƒ£ è¿”å› JWT|æœåŠ¡ç«¯æŠŠ JWT è¿”å›ç»™å‰ç«¯ï¼ˆé€šå¸¸å­˜è¿› localStorageï¼‰|
|3ï¸âƒ£ æºå¸¦ JWT è¯·æ±‚|åç»­æ¯æ¬¡è¯·æ±‚ï¼Œå‰ç«¯åœ¨ Authorization å¤´ä¸­å¸¦ä¸Š JWT|
|4ï¸âƒ£ æœåŠ¡ç«¯éªŒè¯|æœåŠ¡ç«¯è§£ç  JWT â†’ éªŒè¯ç­¾å â†’ æ£€æŸ¥æœ‰æ•ˆæœŸ â†’ ç¡®è®¤èº«ä»½|
|5ï¸âƒ£ æ”¾è¡Œè¯·æ±‚|éªŒè¯é€šè¿‡ â†’ è¿”å›æ•°æ®ï¼›å¤±è´¥ â†’ è¿”å› 401 é”™è¯¯|

## JWTçš„ä¼˜ç‚¹ä¸ç¼ºç‚¹
|ä¼˜ç‚¹|ç¼ºç‚¹|
|---|---|
|âœ…æ— çŠ¶æ€ï¼šæœåŠ¡ç«¯ä¸å­˜sessionï¼Œå¯æ°´å¹³æ‰©å±•|âŒæ— æ³•ä¸»åŠ¨æ³¨é”€ï¼ˆé™¤éç”¨é»‘åå•æœºåˆ¶ï¼‰|
|âœ…è‡ªåŒ…å«ï¼šç”¨æˆ·ä¿¡æ¯å’Œæƒé™éƒ½åœ¨tokené‡Œ|âŒä¸€æ—¦æ³„éœ²ï¼Œæ”»å‡»è€…å¯é•¿æœŸå†’ç”¨|
|âœ…è·¨åŸŸå‹å¥½ï¼šé€‚åˆå‰åç«¯åˆ†ç¦»æ¶æ„|âŒä½“ç§¯æ¯”sessionå¤§ï¼ˆä¸è¿‡å¯æ¥å—ï¼‰|

## æ€»ç»“
ğŸ¯ JWT å°±åƒä¸€å¼ â€œç”µå­èº«ä»½è¯â€ï¼Œå®ƒæŠŠä½ çš„èº«ä»½ä¿¡æ¯åŠ å¯†å°è£…æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ å¸¦ç€å®ƒå»è®¿é—®ç³»ç»Ÿï¼Œç³»ç»Ÿç”¨â€œé’¥åŒ™â€éªŒè¯å®ƒæ˜¯å¦çœŸå®æœ‰æ•ˆ
+ JWTä¸å»ºè®®å­˜å‚¨å¯†ç ã€é“¶è¡Œå¡å·ç­‰æ•æ„Ÿä¿¡æ¯
+ ä¸€å®šè¦ç”¨HTTPSä¼ è¾“JWTï¼Œé˜²æ­¢è¢«çªƒå¬
+ è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´ï¼ˆå¦‚30min~2hï¼‰

## JWT FastApiç¤ºä¾‹æ¨¡æ¿

**âœ… è¿›é˜¶ç‰ˆæ ¸å¿ƒåŠŸèƒ½ï¼ˆç”Ÿäº§çº§ï¼‰**  
|åŠŸèƒ½|è¯´æ˜|
|---|---|
|ğŸ” çœŸå®ç”¨æˆ·æ•°æ®åº“ï¼ˆSQLAlchemy + PostgreSQLï¼‰|ä½¿ç”¨ ORM æŒä¹…åŒ–ç”¨æˆ·æ•°æ®}|
|ğŸ”‘ JWT åˆ·æ–°ä»¤ç‰Œï¼ˆRefresh Tokenï¼‰æœºåˆ¶|å®ç°â€œé•¿æœŸç™»å½•â€ + â€œå®‰å…¨ç™»å‡ºâ€|
|ğŸ”´ Redis é»‘åå•ï¼ˆToken Revocationï¼‰|æ”¯æŒä¸»åŠ¨ç™»å‡ºã€å¼ºåˆ¶å¤±æ•ˆ Token|
|ğŸ“¦ ç¯å¢ƒå˜é‡é…ç½®ï¼ˆ.envï¼‰|æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚å¯†é’¥ã€DB è¿æ¥ï¼‰ä¸ç¡¬ç¼–ç |
|ğŸ›¡ï¸ Passlib å¯†ç å“ˆå¸Œ + éªŒè¯|å®‰å…¨å­˜å‚¨ä¸æ¯”å¯¹å¯†ç |
|ğŸŒ HTTPS æ”¯æŒï¼ˆå¼€å‘æ—¶å¯å¿½ç•¥ï¼‰|ç”Ÿäº§ç¯å¢ƒå¿…å¤‡|
|ğŸ“Š Swagger UI + è‡ªåŠ¨æ–‡æ¡£|ä¸€é”®ç”Ÿæˆæ¥å£æ–‡æ¡£|

### é¡¹ç›®ç»“æ„
```
jwt_fastapi_advanced/
â”œâ”€â”€ .env                    â† ç¯å¢ƒå˜é‡æ–‡ä»¶ï¼ˆä¸æäº¤åˆ° Gitï¼‰
â”œâ”€â”€ main.py                 â† ä¸»åº”ç”¨
â”œâ”€â”€ auth.py                 â† JWT å·¥å…· + åˆ·æ–°ä»¤ç‰Œ + é»‘åå•
â”œâ”€â”€ models.py               â† SQLAlchemy æ¨¡å‹
â”œâ”€â”€ database.py             â† æ•°æ®åº“è¿æ¥é…ç½®
â”œâ”€â”€ schemas.py              â† Pydantic æ•°æ®æ ¡éªŒæ¨¡å‹
â”œâ”€â”€ requirements.txt        â† ä¾èµ–æ–‡ä»¶
â””â”€â”€ README.md
```

**.envç¯å¢ƒå˜é‡**  
```
# âš ï¸ è¯·æ›¿æ¢ä¸ºä½ çš„å®é™…å€¼
SECRET_KEY=your-32-char-secret-key-here-generated-by-openssl
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# æ•°æ®åº“è¿æ¥ï¼ˆPostgreSQL ç¤ºä¾‹ï¼‰
DATABASE_URL=postgresql+psycopg2://user:password@localhost:5432/jwt_app

# Redis é…ç½®ï¼ˆç”¨äºé»‘åå•ï¼‰
REDIS_URL=redis://localhost:6379/0
```
ğŸ” ç”Ÿæˆ SECRET_KEY å‘½ä»¤ï¼ˆæ¨èï¼‰ï¼š
```
openssl rand -hex 32
```

**database.pyæ•°æ®åº“è¿æ¥**  
```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**models.pyæ•°æ®åº“æ¨¡å‹ï¼ˆç”¨æˆ·è¡¨ï¼‰**  
```python
# models.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from database import Base
from datetime import datetime
from passlib.context import CryptContext

# å¯†ç å“ˆå¸Œä¸Šä¸‹æ–‡
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def get_password_hash(password: str) -> str:
        return pwd_context.hash(password)
```

**schemas.py Pydanticæ¨¡å‹ï¼ˆè¯·æ±‚/å“åº”æ ¡éªŒï¼‰**  
```python
# schemas.py
from pydantic import BaseModel
from typing import Optional

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class TokenPayload(BaseModel):
    sub: str
    exp: int
```

**auth.py JWTæ ¸å¿ƒé€»è¾‘ï¼ˆå«åˆ·æ–°ä»¤ç‰Œ+é»‘åå•ï¼‰**  
```python
# auth.py
import jwt
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from typing import Optional
from models import User, UserCreate
from database import get_db
from sqlalchemy.orm import Session
from redis import Redis
from dotenv import load_dotenv
import os

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS"))

# Redis å®¢æˆ·ç«¯ï¼ˆç”¨äºé»‘åå•ï¼‰
redis_client = Redis.from_url(os.getenv("REDIS_URL"), decode_responses=True)

# ğŸ” ç”Ÿæˆ JWT Token
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ğŸ” ç”Ÿæˆåˆ·æ–° Token
def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ğŸš« å°† Token åŠ å…¥é»‘åå•ï¼ˆç™»å‡ºæ—¶è°ƒç”¨ï¼‰
def invalidate_token(token: str, expires_in: int):
    redis_client.setex(f"revoked_token:{token}", expires_in, "1")

# ğŸ›‘ æ£€æŸ¥ Token æ˜¯å¦å·²è¢«æ’¤é”€
def is_token_revoked(token: str) -> bool:
    return redis_client.exists(f"revoked_token:{token}") == 1

# ğŸ” éªŒè¯ç”¨æˆ·ç™»å½•
def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not User.verify_password(password, user.hashed_password):
        return None
    return user

# ğŸ§‘â€ğŸ’¼ è·å–å½“å‰ç”¨æˆ·ï¼ˆä¾èµ–é¡¹ï¼‰
def get_current_user(token: str = Depends(get_token), db: Session = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except jwt.PyJWTError:
        raise credentials_exception

    # æ£€æŸ¥æ˜¯å¦è¢«æ’¤é”€
    if is_token_revoked(token):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has been revoked",
            headers={"WWW-Authenticate": "Bearer"},
        )

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise credentials_exception
    return user

# ğŸ“¥ ä» Authorization å¤´è·å– Token
def get_token():
    pass
```

**main.pyä¸»åº”ç”¨æ–‡ä»¶**  
```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from auth import authenticate_user, create_access_token, create_refresh_token, get_current_user
from models import UserCreate, UserLogin, UserResponse, Token
from database import get_db

app = FastAPI(title="è¿›é˜¶ç‰ˆ JWT FastAPI æ¨¡æ¿", version="1.0")

# ğŸŒ æ³¨å†Œè·¯ç”±
@app.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register(user_data: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.username == user_data.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already registered")
    hashed_password = User.get_password_hash(user_data.password)
    new_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@app.post("/login", response_model=Token)
def login(login_data: UserLogin, db: Session = Depends(get_db)):
    user = authenticate_user(db, login_data.username, login_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/refresh", response_model=Token)
def refresh_token(refresh_token: str = Depends(get_token), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid refresh token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/logout")
def logout(token: str = Depends(get_token)):
    # ä» JWT ä¸­æå–å­ï¼ˆusernameï¼‰æˆ–ç›´æ¥ä½¿ç”¨ token æœ¬èº«
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    # å°† token åŠ å…¥é»‘åå•ï¼ˆè¿‡æœŸæ—¶é—´ = refresh token æœ‰æ•ˆæœŸï¼‰
    invalidate_token(token, REFRESH_TOKEN_EXPIRE_DAYS * 86400)
    return {"message": "Successfully logged out"}

# ğŸ›¡ï¸ ä¿æŠ¤æ¥å£
@app.get("/protected")
def protected_route(current_user: User = Depends(get_current_user)):
    return {
        "message": f"Hello, {current_user.username}! You are authenticated.",
        "user": current_user.dict()
    }

@app.get("/me")
def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```








