# JWT

## ä¸ºä»€ä¹ˆè¦ç”¨JWT
æƒ³è±¡ä¸€ä¸‹ä½ åŽ»é¤åŽ…åƒé¥­ï¼š
+ ä½ èµ°è¿›é¤åŽ…ï¼ŒæœåŠ¡å‘˜é—®ï¼šâ€œæ‚¨æœ‰é¢„çº¦å—ï¼Ÿâ€
+ ä½ è¯´ï¼šâ€œæ²¡æœ‰ï¼Œä½†æˆ‘å¸¦äº†èº«ä»½è¯ã€‚â€
+ æœåŠ¡å‘˜æ ¸å¯¹èº«ä»½è¯ â†’ ç¡®è®¤ä½ æ˜¯çœŸå®žé¡¾å®¢ â†’ å…è®¸ä½ å…¥åº§ã€‚

âœ… è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯ â€œè®¤è¯â€ï¼ˆAuthenticationï¼‰ â€”â€” éªŒè¯ä½ æ˜¯è°ã€‚

è€Œ â€œæŽˆæƒâ€ï¼ˆAuthorizationï¼‰ æ˜¯ï¼šä½ åä¸‹æ¥åŽï¼ŒæœåŠ¡å‘˜é—®ï¼šâ€œä½ æƒ³åƒç‰›è‚‰è¿˜æ˜¯é±¼ï¼Ÿâ€
ä½ è¯´ï¼šâ€œæˆ‘æƒ³åƒç‰›æŽ’ã€‚â€
æœåŠ¡å‘˜è¯´ï¼šâ€œå¥½çš„ï¼Œè¿™æ˜¯æ‚¨çš„ç‰›æŽ’ã€‚â€

ðŸ‘‰ æ‰€ä»¥ï¼š
+ è®¤è¯ï¼šä½ æ˜¯è°ï¼Ÿï¼ˆèº«ä»½éªŒè¯ï¼‰
+ æŽˆæƒï¼šä½ èƒ½åšä»€ä¹ˆï¼Ÿï¼ˆæƒé™æŽ§åˆ¶ï¼‰

## JWTæ˜¯ä»€ä¹ˆ
âœ… JWTï¼ˆJSON Web Tokenï¼‰å°±æ˜¯ä¸€ä¸ªâ€œæ•°å­—èº«ä»½è¯â€ï¼Œå®ƒæŠŠä½ çš„èº«ä»½ä¿¡æ¯å’Œæƒé™ä¿¡æ¯ï¼ŒåŠ å¯†æ‰“åŒ…æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ æ‹¿ç€å®ƒåŽ»è®¿é—®ç³»ç»Ÿï¼Œç³»ç»Ÿå°±èƒ½ç«‹åˆ»è®¤å‡ºä½ 

## JWTçš„ç»“æž„ï¼šé•¿ä»€ä¹ˆæ ·
ä¸€ä¸ª JWT å­—ç¬¦ä¸²çœ‹èµ·æ¥åƒè¿™æ ·ï¼š
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
å®ƒç”± ä¸‰éƒ¨åˆ†ç»„æˆï¼Œç”¨ . åˆ†éš”ï¼š
```
Header.Payload.Signature
```
æˆ‘ä»¬æ¥æ‹†å¼€çœ‹ï¼Œå°±åƒæ‹†ä¸€ä¸ªä¸‰æ˜Žæ²»ä¸€æ ·ï¼š

**ç¬¬ä¸€å±‚ï¼š Headerï¼ˆå¤´éƒ¨ï¼‰**  
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
+ algï¼šç­¾åç®—æ³•ï¼ˆæ¯”å¦‚ HS256ï¼Œè¡¨ç¤ºç”¨ HmacSHA256 åŠ å¯†ï¼‰
+ typï¼šç±»åž‹ï¼Œè¿™é‡Œæ˜¯JWT

ðŸ‘‰ è¿™éƒ¨åˆ†å‘Šè¯‰ç³»ç»Ÿï¼šâ€œæˆ‘æ˜¯ä¸€ä¸ª JWTï¼Œç”¨ä»€ä¹ˆç®—æ³•ç­¾çš„ã€‚â€

**ç¬¬äºŒå±‚ï¼šPayloadï¼ˆå†…å®¹ï¼‰â€”â€”â€”â€” ä½ çš„èº«ä»½è¯ä¿¡æ¯**  
```
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```
+ subï¼ˆsubjectï¼‰ï¼šç”¨æˆ·å”¯ä¸€ IDï¼ˆæ¯”å¦‚æ•°æ®åº“ä¸»é”®ï¼‰
+ nameï¼šç”¨æˆ·å
+ iatï¼ˆissued atï¼‰ï¼šç­¾å‘æ—¶é—´ï¼ˆæ—¶é—´æˆ³ï¼‰

ðŸ‘‰ ä½ å¯ä»¥æŠŠè¿™é‡Œæƒ³è±¡æˆä½ çš„â€œèº«ä»½è¯ä¸Šçš„ä¸ªäººä¿¡æ¯â€ã€‚

> âš ï¸ æ³¨æ„ï¼šè™½ç„¶ Payload å¯ä»¥è¢«è§£ç ï¼ˆä¸æ˜¯åŠ å¯†ï¼ï¼‰ï¼Œä½†ä¸èƒ½éšæ„ç¯¡æ”¹ï¼Œå¦åˆ™ç­¾åä¼šå¤±æ•ˆã€‚

**ç¬¬ä¸‰å±‚ï¼šSignatureï¼ˆç­¾åï¼‰â€”â€”â€”â€”ä½ çš„é˜²ä¼ªå°ç« **  
è¿™æ˜¯æœ€æ ¸å¿ƒçš„ä¸€å±‚ï¼
å®ƒæ˜¯ç”±ä»¥ä¸‹ä¸‰éƒ¨åˆ†æ‹¼èµ·æ¥ï¼Œå†ç”¨ å¯†é’¥ï¼ˆsecret keyï¼‰ åšç­¾åï¼š
```
HMACSHA256(
  base64UrlEncode(Header) + "." +
  base64UrlEncode(Payload),
  secret
)
```
ðŸ‘‰ å°±åƒä½ èº«ä»½è¯ä¸Šçš„é˜²ä¼ªæ°´å°ï¼Œåªæœ‰å®˜æ–¹æœ‰â€œå°ç« é’¥åŒ™â€ï¼Œåˆ«äººä¼ªé€ ä¸äº†ã€‚

## JWTå·¥ä½œæµç¨‹ï¼ˆç”¨ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼‰
æˆ‘ä»¬ç”¨ä¸€ä¸ª â€œåŽ»é“¶è¡Œå–é’±â€ çš„æ•…äº‹æ¥ç†è§£ï¼š

ðŸŽ¬ åœºæ™¯ï¼šå°æ˜ŽåŽ»é“¶è¡Œå–é’±
1. å°æ˜Žèµ°è¿›é“¶è¡Œï¼ŒæŸœå‘˜é—®ï¼šâ€œè¯·å‡ºç¤ºæ‚¨çš„èº«ä»½è¯å’Œé“¶è¡Œå¡ã€‚â€
2. å°æ˜Žæ‹¿å‡ºèº«ä»½è¯ + é“¶è¡Œå¡ â†’ æŸœå‘˜æ ¸å¯¹ä¿¡æ¯ã€‚
3. æ ¸å¯¹æ— è¯¯åŽï¼ŒæŸœå‘˜ç»™å°æ˜Žä¸€ä¸ª â€œèº«ä»½ä»¤ç‰Œâ€ï¼ˆJWTï¼‰ï¼Œä¸Šé¢å†™ç€ï¼š
   - â€œæŒå¡äººï¼šå°æ˜Žâ€
   - â€œå¡å·ï¼š6222 0000 1111 2222â€
   - â€œæœ‰æ•ˆæœŸï¼š2025-12-18 ~ 2025-12-19â€
   - â€œç­¾åï¼šé˜²ä¼ªç« ï¼ˆåªæœ‰é“¶è¡ŒçŸ¥é“ï¼‰â€
4. å°æ˜Žæ‹¿ç€è¿™ä¸ªä»¤ç‰Œï¼Œèµ°å‘ ATM æœºã€‚
5. ATM æœºæ‰«äº†ä»¤ç‰Œ â†’ è§£ç  Header + Payload â†’ ç„¶åŽç”¨ é“¶è¡Œçš„â€œé’¥åŒ™â€ éªŒè¯ Signature æ˜¯å¦æœ‰æ•ˆã€‚
6. âœ… éªŒè¯é€šè¿‡ â†’ ATM æœºç¡®è®¤ï¼šâ€œè¿™æ˜¯çœŸå®žçš„å°æ˜Žï¼Œæœ‰æƒé™å–é’±ï¼â€
7. å°æ˜Žè¾“å…¥å¯†ç  â†’ æˆåŠŸå–é’±ï¼

**å…³é”®ç‚¹æ€»ç»“**  
|æ­¥éª¤|è¯´æ˜Ž|
|---|---|
|1ï¸âƒ£ ç™»å½•|ç”¨æˆ·æäº¤è´¦å·å¯†ç  â†’ æœåŠ¡ç«¯éªŒè¯ â†’ ç”Ÿæˆ JWT|
|2ï¸âƒ£ è¿”å›ž JWT|æœåŠ¡ç«¯æŠŠ JWT è¿”å›žç»™å‰ç«¯ï¼ˆé€šå¸¸å­˜è¿› localStorageï¼‰|
|3ï¸âƒ£ æºå¸¦ JWT è¯·æ±‚|åŽç»­æ¯æ¬¡è¯·æ±‚ï¼Œå‰ç«¯åœ¨ Authorization å¤´ä¸­å¸¦ä¸Š JWT|
|4ï¸âƒ£ æœåŠ¡ç«¯éªŒè¯|æœåŠ¡ç«¯è§£ç  JWT â†’ éªŒè¯ç­¾å â†’ æ£€æŸ¥æœ‰æ•ˆæœŸ â†’ ç¡®è®¤èº«ä»½|
|5ï¸âƒ£ æ”¾è¡Œè¯·æ±‚|éªŒè¯é€šè¿‡ â†’ è¿”å›žæ•°æ®ï¼›å¤±è´¥ â†’ è¿”å›ž 401 é”™è¯¯|

## JWTçš„ä¼˜ç‚¹ä¸Žç¼ºç‚¹
|ä¼˜ç‚¹|ç¼ºç‚¹|
|---|---|
|âœ…æ— çŠ¶æ€ï¼šæœåŠ¡ç«¯ä¸å­˜sessionï¼Œå¯æ°´å¹³æ‰©å±•|âŒæ— æ³•ä¸»åŠ¨æ³¨é”€ï¼ˆé™¤éžç”¨é»‘åå•æœºåˆ¶ï¼‰|
|âœ…è‡ªåŒ…å«ï¼šç”¨æˆ·ä¿¡æ¯å’Œæƒé™éƒ½åœ¨tokené‡Œ|âŒä¸€æ—¦æ³„éœ²ï¼Œæ”»å‡»è€…å¯é•¿æœŸå†’ç”¨|
|âœ…è·¨åŸŸå‹å¥½ï¼šé€‚åˆå‰åŽç«¯åˆ†ç¦»æž¶æž„|âŒä½“ç§¯æ¯”sessionå¤§ï¼ˆä¸è¿‡å¯æŽ¥å—ï¼‰|

## æ€»ç»“
ðŸŽ¯ JWT å°±åƒä¸€å¼ â€œç”µå­èº«ä»½è¯â€ï¼Œå®ƒæŠŠä½ çš„èº«ä»½ä¿¡æ¯åŠ å¯†å°è£…æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ å¸¦ç€å®ƒåŽ»è®¿é—®ç³»ç»Ÿï¼Œç³»ç»Ÿç”¨â€œé’¥åŒ™â€éªŒè¯å®ƒæ˜¯å¦çœŸå®žæœ‰æ•ˆ
+ JWTä¸å»ºè®®å­˜å‚¨å¯†ç ã€é“¶è¡Œå¡å·ç­‰æ•æ„Ÿä¿¡æ¯
+ ä¸€å®šè¦ç”¨HTTPSä¼ è¾“JWTï¼Œé˜²æ­¢è¢«çªƒå¬
+ è®¾ç½®åˆç†çš„è¿‡æœŸæ—¶é—´ï¼ˆå¦‚30min~2hï¼‰

## JWT FastApiç¤ºä¾‹æ¨¡æ¿

**âœ… è¿›é˜¶ç‰ˆæ ¸å¿ƒåŠŸèƒ½ï¼ˆç”Ÿäº§çº§ï¼‰**  
|åŠŸèƒ½|è¯´æ˜Ž|
|---|---|
|ðŸ” çœŸå®žç”¨æˆ·æ•°æ®åº“ï¼ˆSQLAlchemy + PostgreSQLï¼‰|ä½¿ç”¨ ORM æŒä¹…åŒ–ç”¨æˆ·æ•°æ®}|
|ðŸ”‘ JWT åˆ·æ–°ä»¤ç‰Œï¼ˆRefresh Tokenï¼‰æœºåˆ¶|å®žçŽ°â€œé•¿æœŸç™»å½•â€ + â€œå®‰å…¨ç™»å‡ºâ€|
|ðŸ”´ Redis é»‘åå•ï¼ˆToken Revocationï¼‰|æ”¯æŒä¸»åŠ¨ç™»å‡ºã€å¼ºåˆ¶å¤±æ•ˆ Token|
|ðŸ“¦ çŽ¯å¢ƒå˜é‡é…ç½®ï¼ˆ.envï¼‰|æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚å¯†é’¥ã€DB è¿žæŽ¥ï¼‰ä¸ç¡¬ç¼–ç |
|ðŸ›¡ï¸ Passlib å¯†ç å“ˆå¸Œ + éªŒè¯|å®‰å…¨å­˜å‚¨ä¸Žæ¯”å¯¹å¯†ç |
|ðŸŒ HTTPS æ”¯æŒï¼ˆå¼€å‘æ—¶å¯å¿½ç•¥ï¼‰|ç”Ÿäº§çŽ¯å¢ƒå¿…å¤‡|
|ðŸ“Š Swagger UI + è‡ªåŠ¨æ–‡æ¡£|ä¸€é”®ç”ŸæˆæŽ¥å£æ–‡æ¡£|

### é¡¹ç›®ç»“æž„
```
jwt_fastapi_advanced/
â”œâ”€â”€ .env                    â† çŽ¯å¢ƒå˜é‡æ–‡ä»¶ï¼ˆä¸æäº¤åˆ° Gitï¼‰
â”œâ”€â”€ main.py                 â† ä¸»åº”ç”¨
â”œâ”€â”€ auth.py                 â† JWT å·¥å…· + åˆ·æ–°ä»¤ç‰Œ + é»‘åå•
â”œâ”€â”€ models.py               â† SQLAlchemy æ¨¡åž‹
â”œâ”€â”€ database.py             â† æ•°æ®åº“è¿žæŽ¥é…ç½®
â”œâ”€â”€ schemas.py              â† Pydantic æ•°æ®æ ¡éªŒæ¨¡åž‹
â”œâ”€â”€ requirements.txt        â† ä¾èµ–æ–‡ä»¶
â””â”€â”€ README.md

# æ›´æ–°åŽçš„é¡¹ç›®ç»“æž„
your-jwt-fastapi-project/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ .env
â”œâ”€â”€ nginx/
â”‚   â”œâ”€â”€ nginx.conf
â”‚   â””â”€â”€ conf.d/
â”‚       â””â”€â”€ fastapi.conf
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ auth.py
â”‚   â”œâ”€â”€ models.py
â”‚   â”œâ”€â”€ schemas.py
â”‚   â”œâ”€â”€ database.py
â”‚   â””â”€â”€ requirements.txt
â”œâ”€â”€ .dockerignore
â””â”€â”€ README.md
```

**.envçŽ¯å¢ƒå˜é‡**  
```
# âš ï¸ è¯·æ›¿æ¢ä¸ºä½ çš„å®žé™…å€¼
SECRET_KEY=your-32-char-secret-key-here-generated-by-openssl
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# æ•°æ®åº“è¿žæŽ¥ï¼ˆPostgreSQL ç¤ºä¾‹ï¼‰
DATABASE_URL=postgresql+psycopg2://user:password@localhost:5432/jwt_app

# Redis é…ç½®ï¼ˆç”¨äºŽé»‘åå•ï¼‰
REDIS_URL=redis://localhost:6379/0

# æ›´æ–°åŽçš„çŽ¯å¢ƒå˜é‡
# åº”ç”¨é…ç½®
APP_HOST=0.0.0.0
APP_PORT=8000

# JWT é…ç½®
SECRET_KEY=your-32-char-secret-key-here-generated-by-openssl
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# æ•°æ®åº“é…ç½®
DATABASE_URL=postgresql+psycopg2://user:password@postgres:5432/jwt_app

# Redis é…ç½®
REDIS_URL=redis://redis:6379/0

# Nginx é…ç½®
DOMAIN=yourdomain.com
```
ðŸ” ç”Ÿæˆ SECRET_KEY å‘½ä»¤ï¼ˆæŽ¨èï¼‰ï¼š
```
openssl rand -hex 32
```

**database.pyæ•°æ®åº“è¿žæŽ¥**  
```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv
import os

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**models.pyæ•°æ®åº“æ¨¡åž‹ï¼ˆç”¨æˆ·è¡¨ï¼‰**  
```python
# models.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from database import Base
from datetime import datetime
from passlib.context import CryptContext

# å¯†ç å“ˆå¸Œä¸Šä¸‹æ–‡
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def get_password_hash(password: str) -> str:
        return pwd_context.hash(password)
```

**schemas.py Pydanticæ¨¡åž‹ï¼ˆè¯·æ±‚/å“åº”æ ¡éªŒï¼‰**  
```python
# schemas.py
from pydantic import BaseModel
from typing import Optional

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class TokenPayload(BaseModel):
    sub: str
    exp: int
```

**auth.py JWTæ ¸å¿ƒé€»è¾‘ï¼ˆå«åˆ·æ–°ä»¤ç‰Œ+é»‘åå•ï¼‰**  
```python
# auth.py
import jwt
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from typing import Optional
from models import User, UserCreate
from database import get_db
from sqlalchemy.orm import Session
from redis import Redis
from dotenv import load_dotenv
import os

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS"))

# Redis å®¢æˆ·ç«¯ï¼ˆç”¨äºŽé»‘åå•ï¼‰
redis_client = Redis.from_url(os.getenv("REDIS_URL"), decode_responses=True)

# ðŸ” ç”Ÿæˆ JWT Token
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ðŸ” ç”Ÿæˆåˆ·æ–° Token
def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# ðŸš« å°† Token åŠ å…¥é»‘åå•ï¼ˆç™»å‡ºæ—¶è°ƒç”¨ï¼‰
def invalidate_token(token: str, expires_in: int):
    redis_client.setex(f"revoked_token:{token}", expires_in, "1")

# ðŸ›‘ æ£€æŸ¥ Token æ˜¯å¦å·²è¢«æ’¤é”€
def is_token_revoked(token: str) -> bool:
    return redis_client.exists(f"revoked_token:{token}") == 1

# ðŸ” éªŒè¯ç”¨æˆ·ç™»å½•
def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = db.query(User).filter(User.username == username).first()
    if not user:
        return None
    if not User.verify_password(password, user.hashed_password):
        return None
    return user

# ðŸ§‘â€ðŸ’¼ èŽ·å–å½“å‰ç”¨æˆ·ï¼ˆä¾èµ–é¡¹ï¼‰
def get_current_user(token: str = Depends(get_token), db: Session = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except jwt.PyJWTError:
        raise credentials_exception

    # æ£€æŸ¥æ˜¯å¦è¢«æ’¤é”€
    if is_token_revoked(token):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has been revoked",
            headers={"WWW-Authenticate": "Bearer"},
        )

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise credentials_exception
    return user

# ðŸ“¥ ä»Ž Authorization å¤´èŽ·å– Token
def get_token():
    pass
```

**main.pyä¸»åº”ç”¨æ–‡ä»¶**  
```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from auth import authenticate_user, create_access_token, create_refresh_token, get_current_user
from models import UserCreate, UserLogin, UserResponse, Token
from database import get_db

app = FastAPI(title="è¿›é˜¶ç‰ˆ JWT FastAPI æ¨¡æ¿", version="1.0")

# ðŸŒ æ³¨å†Œè·¯ç”±
@app.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register(user_data: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.username == user_data.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already registered")
    hashed_password = User.get_password_hash(user_data.password)
    new_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@app.post("/login", response_model=Token)
def login(login_data: UserLogin, db: Session = Depends(get_db)):
    user = authenticate_user(db, login_data.username, login_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/refresh", response_model=Token)
def refresh_token(refresh_token: str = Depends(get_token), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid refresh token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    access_token = create_access_token(data={"sub": user.username})
    refresh_token = create_refresh_token(data={"sub": user.username})
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@app.post("/logout")
def logout(token: str = Depends(get_token)):
    # ä»Ž JWT ä¸­æå–å­ï¼ˆusernameï¼‰æˆ–ç›´æŽ¥ä½¿ç”¨ token æœ¬èº«
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    # å°† token åŠ å…¥é»‘åå•ï¼ˆè¿‡æœŸæ—¶é—´ = refresh token æœ‰æ•ˆæœŸï¼‰
    invalidate_token(token, REFRESH_TOKEN_EXPIRE_DAYS * 86400)
    return {"message": "Successfully logged out"}

# ðŸ›¡ï¸ ä¿æŠ¤æŽ¥å£
@app.get("/protected")
def protected_route(current_user: User = Depends(get_current_user)):
    return {
        "message": f"Hello, {current_user.username}! You are authenticated.",
        "user": current_user.dict()
    }

@app.get("/me")
def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```
### é¡¹ç›®éƒ¨ç½²
**nginx/nginx.conf**  
```
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                       '$status $body_bytes_sent "$http_referer" '
                       '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # SSL é…ç½®ï¼ˆLet's Encryptï¼‰
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # é…ç½®åå‘ä»£ç†
    upstream fastapi_app {
        server app:8000;
    }

    server {
        listen 80;
        server_name ${DOMAIN};

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name ${DOMAIN};

        ssl_certificate_file /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
        ssl_certificate_key_file /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

        location / {
            proxy_pass http://fastapi_app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
        }

        location /docs {
            proxy_pass http://fastapi_app/docs;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /redoc {
            proxy_pass http://fastapi_app/redoc;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

**nginx/conf.d/fastapi.conf**  
```
# nginx/conf.d/fastapi.conf
server {
    listen 80;
    server_name ${DOMAIN};

    location / {
        return 301 https://$server_name$request_uri;
    }
}
```

**docker-compose.ymlï¼ˆæ ¸å¿ƒé…ç½®ï¼‰**  
```
version: '3.8'

services:
  # FastAPI åº”ç”¨
  app:
    build:
      context: ./app
      dockerfile: Dockerfile
    container_name: fastapi_jwt_app
    ports:
      - "8000:8000"
    environment:
      - APP_HOST=0.0.0.0
      - APP_PORT=8000
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
      - REFRESH_TOKEN_EXPIRE_DAYS=${REFRESH_TOKEN_EXPIRE_DAYS}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    depends_on:
      - postgres
      - redis
    networks:
      - jwt-network

  # PostgreSQL æ•°æ®åº“
  postgres:
    image: postgres:15
    container_name: postgres_db
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=jwt_app
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./app/database_init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - jwt-network

  # Redisï¼ˆç”¨äºŽ JWT é»‘åå•ï¼‰
  redis:
    image: redis:7
    container_name: redis_cache
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - jwt-network

  # Nginx åå‘ä»£ç† + HTTPS
  nginx:
    image: nginx:alpine
    container_name: nginx_proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./letsencrypt:/etc/letsencrypt
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - app
    networks:
      - jwt-network

# Docker ç½‘ç»œ
networks:
  jwt-network:
    driver: bridge

# æ•°æ®å·
volumes:
  postgres_data:
  redis_data:
```

**app/Dockerfile**  
```
# app/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**å¯åŠ¨ä¸Žéƒ¨ç½²æµç¨‹**  
```
# 1. åˆ›å»ºç›®å½•ç»“æž„
mkdir -p your-jwt-fastapi-project/{app,nginx/conf.d,logs/nginx}

# 2. å°†ä½ çš„ `main.py`, `auth.py`, `models.py`, `schemas.py`, `database.py`, `requirements.txt` æ”¾å…¥ `app/`

# 3. åˆ›å»º `app/database_init.sql`ï¼ˆå¯é€‰ï¼Œç”¨äºŽåˆå§‹åŒ–æ•°æ®åº“ï¼‰
# ç¤ºä¾‹ï¼šCREATE DATABASE jwt_app;

# 4. ä¿®æ”¹ `.env` æ–‡ä»¶ä¸­çš„ `SECRET_KEY` å’Œ `DOMAIN`ï¼ˆå¦‚ yourdomain.comï¼‰

# 5. å¯åŠ¨æœåŠ¡
# è¿›å…¥é¡¹ç›®æ ¹ç›®å½•
cd your-jwt-fastapi-project

# å¯åŠ¨æ‰€æœ‰æœåŠ¡
docker-compose up -d
```

**HTTPSé…ç½®**  
ðŸ” å»ºè®®ä½¿ç”¨ certbot è‡ªåŠ¨èŽ·å– HTTPS è¯ä¹¦ã€‚
```
# åœ¨å®¿ä¸»æœºä¸Šè¿è¡Œ certbotï¼ˆéœ€å¼€æ”¾ 80 ç«¯å£ï¼‰
sudo docker run --rm -it \
  --name certbot \
  -v /etc/letsencrypt:/etc/letsencrypt \
  -v /var/lib/letsencrypt:/var/lib/letsencrypt \
  certbot/certbot certonly --manual --preferred-challenges=http -d yourdomain.com
```
> ðŸ“Œ è¯ä¹¦èŽ·å–åŽï¼Œå°† fullchain.pem å’Œ privkey.pem å¤åˆ¶åˆ° nginx/letsencrypt/live/yourdomain.com/

**è‡ªåŠ¨ç»­æœŸè¯ä¹¦è„šæœ¬**  
> ðŸ“ ä¿å­˜ä¸ºï¼š/opt/letsencrypt/renew.sh
```
#!/bin/bash

# ========================================
# ðŸ› ï¸ Let's Encrypt è‡ªåŠ¨ç»­æœŸè„šæœ¬
# ðŸ“Œ é€‚ç”¨äºŽ Docker Compose + Nginx éƒ¨ç½²
# ðŸ“… å»ºè®®é€šè¿‡ cron æ¯æœˆè¿è¡Œä¸€æ¬¡
# ========================================

# ðŸ”§ é…ç½®å˜é‡
DOMAIN="yourdomain.com"             # æ›¿æ¢ä¸ºä½ çš„åŸŸå
EMAIL="admin@yourdomain.com"      # Let's Encrypt æ³¨å†Œé‚®ç®±
LETS_ENCRYPT_DIR="/etc/letsencrypt"
RENEW_LOG="/var/log/letsencrypt/renew.log"

# ðŸ“ ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
mkdir -p "$(dirname "$RENEW_LOG")"

# ðŸ“ å†™å…¥æ—¥å¿—
echo "[$(date '+%Y-%m-%d %H:%M:%S')] å¼€å§‹ç»­æœŸ Let's Encrypt è¯ä¹¦ for $DOMAIN" >> "$RENEW_LOG"

# âœ… æ£€æŸ¥æ˜¯å¦å·²å®‰è£… certbot
if ! command -v certbot &> /dev/null; then
    echo "âŒ certbot æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… certbotã€‚" >> "$RENEW_LOG"
    exit 1
fi

# ðŸ”„ æ‰§è¡Œç»­æœŸå‘½ä»¤ï¼ˆä½¿ç”¨æ‰‹åŠ¨æ¨¡å¼ï¼Œé¿å… HTTP é‡å®šå‘å†²çªï¼‰
# å¦‚æžœä½ ä¹‹å‰ç”¨çš„æ˜¯ `--manual` æ¨¡å¼ï¼ŒçŽ°åœ¨æ”¹ç”¨ `--webroot` æ›´å®‰å…¨
# ä½†å¦‚æžœä½ ç”¨çš„æ˜¯ `--manual`ï¼Œå¯ä»¥ç»§ç»­ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ï¼ˆéœ€æ‰‹åŠ¨éªŒè¯ï¼‰

# âœ… æŽ¨èæ–¹å¼ï¼šä½¿ç”¨ webroot æ¨¡å¼ï¼ˆéœ€ Nginx ä¿æŒ 80 ç«¯å£å¼€æ”¾ï¼‰
# æ³¨æ„ï¼šå¿…é¡»ç¡®ä¿ `/.well-known/acme-challenge/` è·¯ç”±è¢« Nginx æ­£ç¡®ä»£ç†åˆ°æœ¬åœ°ç›®å½•

# ðŸ“Œ å‡è®¾ä½ å·²é…ç½® Nginx çš„ /etc/letsencrypt/webroot ç›®å½•
# å¹¶ä¸”ä½ çš„ Docker Compose ä¸­ `nginx` å®¹å™¨å·²æ˜ å°„äº† `/.well-known` è·¯å¾„

# ðŸ” ç»­æœŸå‘½ä»¤ï¼ˆæŽ¨èä½¿ç”¨ webroot æ¨¡å¼ï¼‰
if ! certbot renew --webroot --webroot-path=/var/lib/letsencrypt/.well-known/acme-challenge --email="$EMAIL" --agree-tos --no-self-upgrade --quiet; then
    echo "âŒ Let's Encrypt ç»­æœŸå¤±è´¥ï¼" >> "$RENEW_LOG"
    exit 1
else
    echo "âœ… Let's Encrypt è¯ä¹¦ç»­æœŸæˆåŠŸï¼" >> "$RENEW_LOG"
    
    # ðŸ”„ é‡å¯ Nginx ä»¥åŠ è½½æ–°è¯ä¹¦
    echo "ðŸ”„ é‡å¯ Nginx æœåŠ¡..." >> "$RENEW_LOG"
    if docker-compose exec nginx nginx -s reload; then
        echo "âœ… Nginx é‡å¯æˆåŠŸï¼Œè¯ä¹¦å·²ç”Ÿæ•ˆã€‚" >> "$RENEW_LOG"
    else
        echo "âŒ Nginx é‡å¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ—¥å¿—ã€‚" >> "$RENEW_LOG"
        exit 1
    fi
fi

# âœ… ç»“æŸæ—¥å¿—
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ç»­æœŸæµç¨‹ç»“æŸã€‚" >> "$RENEW_LOG"

exit 0
```

# OAuth2



