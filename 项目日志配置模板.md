下面是一个 **完整项目日志配置模板**（含 YAML 配置 + Python 加载脚本 + 使用示例），支持：

- 多 handler（控制台 + 文件）
- 统一日志格式
- 模块化 logger
- `propagate=True`，日志可传递
- 支持日志轮转（按大小）
- 可热重载（通过 `dictConfig`）

---

## 📁 项目结构建议

```
project/
├── config/
│   └── logging.yaml           # 日志配置文件
├── src/
│   ├── __init__.py
│   ├── app/
│   │   ├── __init__.py
│   │   ├── api.py
│   │   └── db.py
│   └── main.py
├── logs/
│   └── app.log                   # 自动创建
└── requirements.txt
```

---

## 📝 1. `config/logging.yaml`

```yaml
version: 1

formatters:
  standard:
    format: "%(asctime)s | %(name)s | %(levelname)s | %(funcName)s:%(lineno)d | %(message)s"
    datefmt: "%Y-%m-%d %H:%M:%S"

  simple:
    format: "%(name)s | %(levelname)s | %(message)s"

handlers:
  console:
    class: logging.StreamHandler
    level: INFO
    formatter: simple
    stream: ext://sys.stderr

  file:
    class: logging.handlers.RotatingFileHandler
    level: DEBUG
    formatter: standard
    filename: logs/app.log
    maxBytes: 10485760  # 10MB
    backupCount: 5      # 保留 5 个旧日志文件

loggers:
  app:
    level: DEBUG
    handlers: [console, file]
    propagate: true  # 重要：让日志传给 root

  app.api:
    level: DEBUG
    handlers: [console, file]
    propagate: true

  app.db:
    level: DEBUG
    handlers: [console, file]
    propagate: true

  app.utils:
    level: INFO
    handlers: [console, file]
    propagate: true

root:
  level: DEBUG
  handlers: [console, file]
  propagate: false  # 一般不建议设为 false，除非你明确不想传
```

> ✅ 说明：
> - `RotatingFileHandler` 自动轮转日志，避免文件过大
> - `propagate: true` 确保子 logger 日志能传给 root
> - `root` 的 `propagate: false` 是为了防止日志无限循环（安全做法）

---

## 📝 2. `src/main.py` —— 启动入口配置日志

```python
import logging.config
import yaml
import os

# 确保 logs 目录存在
os.makedirs("logs", exist_ok=True)

# 加载 YAML 配置
def setup_logging(config_path="config/logging.yaml"):
    with open(config_path, "r", encoding="utf-8") as f:
        config = yaml.safe_load(f)
    logging.config.dictConfig(config)
    print("✅ 日志系统已配置完成！")

# 启动时调用
if __name__ == "__main__":
    setup_logging()
    logger = logging.getLogger("app")

    logger.info("🚀 应用启动成功！")
    logger.debug("调试信息：初始化完成")
```

---

## 📝 3. `src/app/api.py` —— 模块内使用日志

```python
import logging

logger = logging.getLogger("app.api")  # 模块化命名

def get_user(user_id: int):
    logger.debug("开始查询用户，user_id=%d", user_id)
    try:
        # 模拟数据库查询
        user = {"id": user_id, "name": "张三"}
        logger.info("成功查询用户: %s", user)
        return user
    except Exception as e:
        logger.error("查询用户失败，user_id=%d, 错误: %s", user_id, str(e))
        raise
```

---

## 📝 4. `requirements.txt`

```txt
PyYAML>=6.0
```

---

## 🎉 使用效果示例

运行 `python src/main.py` 输出：

```
✅ 日志系统已配置完成！
2026-02-06 15:10:22 | app | INFO | __main__:<module> | 🚀 应用启动成功！
```

查看 `logs/app.log`：

```
2026-02-06 15:10:22 | app.api | DEBUG | get_user:10 | 开始查询用户，user_id=123
2026-02-06 15:10:22 | app.api | INFO | get_user:13 | 成功查询用户: {'id': 123, 'name': '张三'}
```

---

## ✅ 总结：这个模板的亮点

| 亮点 | 说明 |
|------|------|
| ✅ 一个 root + 多子 logger | 模块清晰，便于追踪 |
| ✅ YAML 配置，可读性强 | 易于维护、团队协作 |
| ✅ 日志轮转（10MB） | 防止日志文件过大 |
| ✅ 统一日志格式 | 便于 ELK/Sentry 等工具解析 |
| ✅ 仅配置一次，全局生效 | 安全，无重复 handler |
| ✅ 支持 `loguru` 的平滑迁移 | 如后续改用 loguru，只需替换 `logging` 调用即可 |

---
