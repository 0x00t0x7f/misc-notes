# 数据结构
## 数值
+ 精确数值计算场景（金融、货币），建议使用decimal模块，因为浮点数在计算机中是以二进制表示，二进制无法精确表示部分十进制小数，所以在用浮点数计算可能会出现精度偏差。
+ 追求精度使用 decimal模块，追求性能使用 float。
+ 判断浮点数相等不要使用 ==，比如 m = 0.1 + 0.2; n = 0.3, m == n  # False

## 字符串
+ 建议使用 f-string 进行复杂的字符串连接，简单的字符串连接建议使用 +，避免使用运算符%格式化和连接字符串。
+ 字符串的引号合理使用，始终保持一致性。如果在字符串中包含单引号，可以使用双引号来表示字符串，以此类推。建议多行字符串和文档字符串使用三重引号。单行使用双引号。
+ 避免使用 业务含义模糊的字面量，要么变量名应该 见名知意， 要么使用注释解释其含义。

## 序列
+ 对序列切片时，不建议使用 负值进行切片操作，除非处理字符串反转 "123"[::-1]

## 类型
+ 建议使用 isinstance判断变量类型，而不是使用type，isinstance有很多优势，比如可以判断对象是某个类或其子类的实例，type只能判断一个对象是某个类的实例

# 运算符与表达式
## 运算符
+ 对除法或者分母或者取模运算中的除数为0的情况，要预先进行非0判断
+ 判断是否为 None，应该使用 is、is not 运算符
+ 禁止使用 is、is not运算符比较内置类型
+ 不建议使用高版本的新特性运算符在项目中使用，比如海象运算符
+ 建议使用 not in 判断成员之间的包含关系

## 表达式
+ lambda表达式应该简洁明了，如果内容长或则比较复杂则建议改为常规函数
+ lambda表达式在需要的地方直接使用即可，因为它就是一种匿名函数，无需将其再赋值给某个变量。
+ 列表推导式和生成器表达式可用作简单的逻辑表达，不建议将复杂的逻辑写在一个推导式中。 比如 [x*y for x in xx for y in yy if x > 0 and y > 0]

# 控制语句
+ 同一函数的所有分支返回值类型和个数建议保持一致
+ 函数返回值中不应有 隐式返回值，比如 函数返回值默认是 None
+ 函数返回值 不应返回内置类型映射，比如 None、list..
+ 所有的代码语句都应该是逻辑可达。 比如在 try块中 定义了某个变量，在except中使用，如果在执行该变量前raise error，则会导致进一步的报错
+ 避免在循环/条件语句中包含过多的条件，最好不要超过三层。超过可使用函数、拆分代码等方式简化，提高代码的可维护性和可读性
+ 使用 单下划线 表示循环体中 不使用的循环变量

# 函数&类方法
## 函数参数
+ 禁止使用可变对象作为参数默认值，可变对象作为默认参数其本质是传址，函数内部对其操作会改变该对象。可以使用None代替， 在函数内部判断并初始化该可变对象。 varlist = varlist if varlist else []
+ 禁止使用外部循环中定义的变量、函数
+ 函数参数过多时（一般多于5个），考虑对具有相关性的参数进行封装（封装包括不限于 class、dataclass、namedtuple

## 函数返回值
+ 函数返回值较多，可封装返回结果。参考 【函数参数】
+ 使用 return代替 StopIteration异常来结束生成器

# 变量作用域
+ 非必要避免使用全局变量，跨模块的全局变量可能导致业务代码之间产生数据耦合，建议使用模块级的常量
+ 建议将常量定义在分组的配置文件中
+ 禁止在变量的生命周期内修改其类型， 可能导致代码的行为变得不可预测，容易出错。 如  L = set([1, 2, 3, 1])
+ 不建议覆盖其他作用域中标识符或变量，如  def read_config(path): ...;   path = "/home";  real_path = "/opt";  read_config(real_path);  没用到path这个变量，且可能造成混淆

# 类&面向对象
+ 类的成员属性根据封装的需要严格区分访问权限（public、protectd、private）
+ 子类重写父类方法时，如果父类包含可变参数，则子类继承方法不能缺失该可变参数， 如果子类方法新增参数，则应该指定默认值。 如 father_method(self, args1);  subclass_method(self, args1, args2=None)
+ 子类调用父类初始化方法，建议使用 super()形式
+ 类中的方法建议按照某种规则排列。 如 从前到后，__new__、__init__、__post_init__、魔术方法、@property、@staticmethod、@classmethod、普通方法、保护方法、私有方法
+ 避免在 __init__ 方法外定义类实例属性，除非为了分组，可以通过一个方法或者私有方法在 __init__中调用该方法及时初始化。
+ 重写类的魔法方法时必须返回其原型中指定的返回类型
+ 不建议在子类或类外访问父类受保护的成员变量

# 异常处理
+ try代码块应最小化，将初始化、赋值等不影响整理逻辑性且不可能抛出异常的代码片段，移到try代码块外。
+ 不要用返回值表示异常，使用异常
+ 对异常进行类型转换时要保留原始异常的调用栈信息。 如  except Exception as e: raise ValueError("value error") from e
+ raise 语句必须包含异常实例，应避免捕获异常后直接抛出
+ 对信任外界抛出的异常禁止泄露敏感信息。常见于api接口中抛出的异常，直接在前端展示
+ 同时使用多个 except语句时，注意异常捕获顺序。 按照继承链或者粒度最小原则，从前到后。
+ 除了主进程入口，普通业务代码中不建议使用 SystemExit、sys.exit 等系统级的中断异常
+ 在 finally块中避免使用 break、continue、return、抛出异常，这样做会导致 try块非正常结束，影响程序的可靠性。

# 并行&并发
+ 不要依赖内置类型的原子性。如多线程环境下同时修改同一个对象会导致不确定的行为。 需要加锁。
+ 多线程环境适用于阻塞式IO场景，并行计算应用多进程或协程

# 包&模块
+ 包中应包含 __init__.py 文件，这是目录或者包的标识。
+ 在包中引用模块时，建议使用相对导入
+ 避免使用 from module import * 而引起的命名空间污染
+ 在模块（python中模块是一个命名空间）中使用 __all__ 声明允许外部访问的变量、函数和类
+ 建议使用 importlib库导入函数，而不是使用 __import__

# 标准库
+ 避免使用已经被标记弃用且有明确替代方案的方法或函数
+ 使用 datetime过程中注意时区的影响，对于时区敏感场景应显式指定时区
+ 建议使用sys.path.append代替sys.path.insert(0, path)避免因为模块重名操作改变原始的环境变量

# 代码
+ 建议在项目工程的启动文件中设置执行入口。如 if __name__ == "__main__"
+ 同一项目内编码方式保持一致
+ 使用标准库替代直接调用操作系统命令
+ 生产环境代码中不要包含调试入口点。如 pdb.set_trace、breakpoint()等
+ 不用的代码片段直接删除，不要注释掉。确保所有的代码都是逻辑可达的。

# 文件
+ 建议在创建文件时根据需要指定合适的权限
+ 使用不可信环境输入的文件路径前需对路径进行校验，校验之前先对文件路径进行规范化处理
+ 禁止使用tempfile.mktemp创建临时文件，改用更为安全和稳定的方法。如tempfile.TemporaryFile..
+ 临时文件使用完及时删除或定期清理
+ 构造文件路径时应注意操作系统差异。如windows和linux系统下文件目录是以反斜杠和斜杠区分的，所以屏蔽路径使用库函数。如 os.sep、Path(arg1, arg2)
+ 解压文件时先进行安全检查。

# 序列化
+ 不建议使用 pickle.load、shelve、_pickle.load等库和模块加载外部不可信数据
+ 禁止序列化未加密的敏感数据。敏感数据序列化前需脱敏。
+ 建议使用yaml模块的yaml.safe_load代替yaml.load函数来处理yaml格式数据
+ json序列化时注意数据格式是否满足序列化条件。如 datetime格式的数据会报错，需先转为字符串。

# 数据校验
+ 
